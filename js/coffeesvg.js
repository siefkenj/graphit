// Generated by CoffeeScript 1.3.3
/*
# Reimplimentation of the asciisvg api
#
# (c) Jason Siefken
# GPL 3
*/

/*
# Smart typeof function that will recognize builtin types as well as objects
# that are instances of those types.
*/

var RecordableCanvas, SvgCanvas, typeOf,
  __slice = [].slice;

typeOf = window.typeOf || function(obj) {
  var constructor, constructorName, guess, objectTypes, type;
  guess = typeof obj;
  if (guess !== 'object') {
    return guess;
  }
  if (obj === null) {
    return 'null';
  }
  objectTypes = {
    'array': Array,
    'boolean': Boolean,
    'number': Number,
    'string': String
  };
  for (type in objectTypes) {
    constructor = objectTypes[type];
    if (obj instanceof constructor) {
      return type;
    }
  }
  constructorName = obj.constructor.name;
  if (constructorName === 'Object' || !(constructorName != null)) {
    return 'object';
  }
  return constructorName;
};

/*
# Acts like a canvas, but canvas commands are converted into svg commands
*/


SvgCanvas = (function() {
  var KAPPA, createSvgNode;

  KAPPA = 4.0 * ((Math.sqrt(2) - 1.0) / 3.0);

  createSvgNode = function(tag) {
    return document.createElementNS('http://www.w3.org/2000/svg', tag);
  };

  function SvgCanvas(width, height) {
    this.width = width != null ? width : 550;
    this.height = height != null ? height : 450;
    this._root = createSvgNode('svg');
    this._root.setAttribute("width", this.width);
    this._root.setAttribute("height", this.height);
    this._currentGroup = this._root;
    this._currentPath = '';
  }

  SvgCanvas.prototype.moveTo = function(x, y) {
    return this._currentPath += "M" + x + "," + y + " ";
  };

  SvgCanvas.prototype.lineTo = function(x, y) {
    return this._currentPath += "L" + x + "," + y + " ";
  };

  SvgCanvas.prototype.bezierCurveTo = function(cp1x, cp1y, cp2x, cp2y, x, y) {
    return this._currentPath += "C" + cp1x + "," + cp1y + "," + cp2x + "," + cp2y + "," + x + "," + y + " ";
  };

  SvgCanvas.prototype.quadraticCurveTo = function(cpx, cpy, x, y) {
    return this._currentPath += "Q" + cpx + "," + cpy + "," + x + "," + y + " ";
  };

  SvgCanvas.prototype.closePath = function() {
    return this._currentPath += "Z";
  };

  SvgCanvas.prototype.beginPath = function() {
    return this._currentPath = '';
  };

  SvgCanvas.prototype.text = function(str, x, y, textanchor) {
    var dy, fontsize, node;
    this.textBaseline = 'middle';
    this.textAnchor = 'middle';
    if (textanchor.match('left')) {
      this.textAnchor = 'end';
    } else if (textanchor.match('right')) {
      this.textAnchor = 'start';
    }
    this.textBaseline = 'middle';
    if (textanchor.match('above')) {
      this.textBaseline = 'bottom';
    } else if (textanchor.match('below')) {
      this.textBaseline = 'top';
    }
    fontsize = parseFloat(this.fontsize) || 16;
    dy = -fontsize / 4;
    switch (this.textBaseline) {
      case 'top':
        dy = fontsize;
        break;
      case 'middle':
        dy = fontsize / 2;
    }
    node = createSvgNode("text");
    node.setAttribute("x", x);
    node.setAttribute("y", y + dy);
    node.setAttribute("fill", this.fillStyle);
    if (this.fontFamily) {
      node.setAttribute("font-family", this.fontFamily);
    }
    if (this.fontWeight) {
      node.setAttribute("font-weight", this.fontWeight);
    }
    if (this.fontStyle) {
      node.setAttribute("font-style", this.fontStyle);
    }
    if (this.fontSize) {
      node.setAttribute("font-size", this.fontSize);
    }
    node.setAttribute("text-anchor", this.textAnchor);
    node.appendChild(document.createTextNode(str));
    return this._currentGroup.appendChild(node);
  };

  SvgCanvas.prototype.stroke = function() {
    var node;
    node = createSvgNode("path");
    node.setAttribute("d", this._currentPath);
    node.setAttribute("fill", "none");
    node.setAttribute("stroke", this.strokeStyle);
    node.setAttribute("stroke-width", this.lineWidth);
    if (this.lineJoin) {
      node.setAttribute("stroke-linejoin", this.lineJoin);
    }
    if (this.lineCap) {
      node.setAttribute("stroke-linecap", this.lineCap);
    }
    return this._currentGroup.appendChild(node);
  };

  SvgCanvas.prototype.fill = function() {
    var node;
    node = createSvgNode("path");
    node.setAttribute("d", this._currentPath);
    node.setAttribute("fill", this.fillStyle);
    return this._currentGroup.appendChild(node);
  };

  SvgCanvas.prototype.fillAndStroke = function() {
    var node;
    node = createSvgNode("path");
    node.setAttribute("d", this._currentPath);
    node.setAttribute("fill", this.fillStyle);
    node.setAttribute("stroke", this.strokeStyle);
    node.setAttribute("stroke-width", this.lineWidth);
    if (this.lineJoin) {
      node.setAttribute("stroke-linejoin", this.lineJoin);
    }
    return this._currentGroup.appendChild(node);
  };

  SvgCanvas.prototype.fillRect = function(x, y, w, h) {
    var node;
    node = createSvgNode("rect");
    node.setAttribute("x", x);
    node.setAttribute("y", y);
    node.setAttribute("width", w);
    node.setAttribute("height", h);
    node.setAttribute("fill", this.fillStyle);
    return this._currentGroup.appendChild(node);
  };

  SvgCanvas.prototype.strokeRect = function(x, y, w, h) {
    var node;
    node = createSvgNode("path");
    node.setAttribute("x", x);
    node.setAttribute("y", y);
    node.setAttribute("width", w);
    node.setAttribute("height", h);
    node.setAttribute("stroke", this.strokeStyle);
    node.setAttribute("stroke-width", this.lineWidth);
    return this._currentGroup.appendChild(node);
  };

  SvgCanvas.prototype.circle = function(x, y, r) {
    return this.ellipse(x, y, r);
  };

  SvgCanvas.prototype.ellipse = function(x, y, r1, r2) {
    var l1, l2;
    if (r2 == null) {
      r2 = r1;
    }
    l1 = r1 * KAPPA;
    l2 = r2 * KAPPA;
    this.moveTo(x + r1, y);
    this.bezierCurveTo(x + r1, y + l1, x + l2, y + r2, x, y + r2);
    this.bezierCurveTo(x - l2, y + r2, x - r1, y + l1, x - r1, y);
    this.bezierCurveTo(x - r1, y - l1, x - l2, y - r2, x, y - r2);
    this.bezierCurveTo(x + l2, y - r2, x + r1, y - l1, x + r1, y);
    return this.moveTo(x, y);
  };

  SvgCanvas.prototype.scale = function(x, y) {
    var node;
    node = createSvgNode('g');
    node.setAttribute("transform", "scale(" + x + "," + y + ")");
    this._currentGroup.appendChild(node);
    return this._currentGroup = node;
  };

  SvgCanvas.prototype.rotate = function(angle) {
    var node;
    node = createSvgNode('g');
    node.setAttribute("transform", "rotate(" + angle + ")");
    this._currentGroup.appendChild(node);
    return this._currentGroup = node;
  };

  SvgCanvas.prototype.translate = function(x, y) {
    var node;
    node = createSvgNode('g');
    node.setAttribute("transform", "translate(" + x + "," + y + ")");
    this._currentGroup.appendChild(node);
    return this._currentGroup = node;
  };

  SvgCanvas.prototype.transform = function(m11, m12, m21, m22, dx, dy) {
    var node;
    node = createSvgNode('g');
    node.setAttribute("transform", "matrix(" + m11 + "," + m22 + "," + m21 + "," + m22 + "," + dx + "," + dy + ")");
    this._currentGroup.appendChild(node);
    return this._currentGroup = node;
  };

  SvgCanvas.prototype.save = function() {
    return this._savedNode = this._currentGroup;
  };

  SvgCanvas.prototype.restore = function() {
    return this._currentGroup = this._savedNode;
  };

  return SvgCanvas;

})();

/*
# Acts like a canvas context, but when issued a drawing
# command, it saves the operation and the state of lineWidth/etc...
# so that it can be replayed to an actual canvas context
*/


RecordableCanvas = (function() {
  var filterStateChanges, makeRecordable, objDiff;

  makeRecordable = function(funcName, parent) {
    return parent[funcName] = function() {
      var args, prop, state, _i, _len, _ref;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      state = {};
      _ref = parent._satefulVariables;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        prop = _ref[_i];
        state[prop] = parent[prop];
      }
      parent._issuedCommands.push({
        command: funcName,
        args: args,
        state: state
      });
    };
  };

  objDiff = function(a, b) {
    var prop, ret;
    ret = {};
    for (prop in b) {
      if ((a[prop] !== b[prop]) || (b[prop] === void 0 && a[prop] !== void 0)) {
        ret[prop] = b[prop];
      }
    }
    return ret;
  };

  filterStateChanges = function(ops) {
    var assgn, changedState, cmd, i, newCmd, prevCmd, ret, val, _i, _ref, _ref1;
    ret = [];
    if (ops.length === 0) {
      return ret;
    }
    newCmd = {
      state: {}
    };
    cmd = ops[0];
    newCmd['command'] = cmd['command'];
    newCmd['args'] = cmd['args'];
    _ref = cmd['state'];
    for (assgn in _ref) {
      val = _ref[assgn];
      if (val != null) {
        newCmd['state'][assgn] = val;
      }
    }
    ret.push(newCmd);
    for (i = _i = 1, _ref1 = ops.length; 1 <= _ref1 ? _i < _ref1 : _i > _ref1; i = 1 <= _ref1 ? ++_i : --_i) {
      prevCmd = ops[i - 1];
      cmd = ops[i];
      changedState = objDiff(prevCmd['state'], cmd['state']);
      newCmd = {
        state: {}
      };
      newCmd['command'] = cmd['command'];
      newCmd['args'] = cmd['args'];
      for (assgn in changedState) {
        val = changedState[assgn];
        newCmd['state'][assgn] = val;
      }
      ret.push(newCmd);
    }
    return ret;
  };

  function RecordableCanvas(width, height) {
    var cmd, _i, _len, _ref;
    this.width = width;
    this.height = height;
    this._satefulVariables = ['lineWidth', 'lineCap', 'miterLimit', 'strokeStyle', 'fillStyle', 'textAlign', 'textBaseline', 'globalAlpha', 'font', 'fontFamily', 'fontSize', 'fontWeight', 'fontStyle'];
    this._ctxCommands = ['scale', 'rotate', 'translate', 'transform', 'beginPath', 'closePath', 'fill', 'stroke', 'clip', 'moveTo', 'lineTo', 'quadraticCurveTo', 'bezierCurveTo', 'arcTo', 'arc', 'rect', 'text', 'strokeText', 'clearRect', 'fillRect', 'strokeRect', 'fillAndStroke', 'circle'];
    _ref = this._ctxCommands;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      cmd = _ref[_i];
      makeRecordable(cmd, this);
    }
    this._issuedCommands = [];
  }

  RecordableCanvas.prototype.playbackTo = function(ctx, mode) {
    var assgn, cmd, ret, s, val, wrap, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6;
    if (mode == null) {
      mode = 'string';
    }
    switch (mode.toLowerCase()) {
      case 'string':
        wrap = function(s) {
          if (typeOf(s) === 'string') {
            return "'" + s + "'";
          } else {
            return s;
          }
        };
        ret = [];
        _ref = filterStateChanges(this._issuedCommands);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          cmd = _ref[_i];
          _ref1 = cmd['state'];
          for (assgn in _ref1) {
            val = _ref1[assgn];
            ret.push("ctx." + assgn + " = " + (wrap(val)) + ";");
          }
          ret.push("ctx." + cmd['command'] + "(" + (((function() {
            var _j, _len1, _ref2, _results;
            _ref2 = cmd['args'];
            _results = [];
            for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
              s = _ref2[_j];
              _results.push(wrap(s));
            }
            return _results;
          })()).join(', ')) + ");");
        }
        ret = ret.join('\n');
        break;
      case 'canvas':
        _ref2 = filterStateChanges(this._issuedCommands);
        for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
          cmd = _ref2[_j];
          _ref3 = cmd['state'];
          for (assgn in _ref3) {
            val = _ref3[assgn];
            ctx[assgn] = val;
          }
          try {
            if (cmd['command'] in this._playbackOverridesCanvas) {
              this._playbackOverridesCanvas[cmd['command']].apply(ctx, cmd['args']);
            } else {
              ctx[cmd['command']].apply(ctx, cmd['args']);
            }
          } catch (e) {
            console.log(e, cmd['command'], cmd['args']);
          }
        }
        ret = null;
        break;
      case 'pdf':
        _ref4 = filterStateChanges(this._issuedCommands);
        for (_k = 0, _len2 = _ref4.length; _k < _len2; _k++) {
          cmd = _ref4[_k];
          try {
            this._playbackOverridesPdf._assignments.call(ctx, cmd['state']);
            if (cmd['command'] in this._playbackOverridesPdf) {
              this._playbackOverridesPdf[cmd['command']].apply(ctx, cmd['args']);
            } else {
              ctx[cmd['command']].apply(ctx, cmd['args']);
            }
          } catch (e) {
            console.log(e, cmd['command'], cmd['args']);
          }
        }
        ret = ctx;
        break;
      case 'svg':
        _ref5 = filterStateChanges(this._issuedCommands);
        for (_l = 0, _len3 = _ref5.length; _l < _len3; _l++) {
          cmd = _ref5[_l];
          _ref6 = cmd['state'];
          for (assgn in _ref6) {
            val = _ref6[assgn];
            ctx[assgn] = val;
          }
          try {
            if (cmd['command'] in this._playbackOverridesSvg) {
              this._playbackOverridesSvg[cmd['command']].apply(ctx, cmd['args']);
            } else {
              ctx[cmd['command']].apply(ctx, cmd['args']);
            }
          } catch (e) {
            console.log(e, cmd['command'], cmd['args']);
          }
        }
        ret = ctx;
        break;
      default:
        throw new Error("Unknown mode " + mode);
    }
    return ret;
  };

  RecordableCanvas.prototype._playbackOverridesCanvas = {
    circle: function(x, y, radius) {
      return this.arc(x, y, radius, 0, 2 * Math.PI, false);
    },
    fillAndStroke: function() {
      this.fill();
      return this.stroke();
    },
    text: function(str, x, y, textanchor) {
      this.textAlign = 'center';
      if (textanchor.match('left')) {
        this.textAlign = 'right';
      } else if (textanchor.match('right')) {
        this.textAlign = 'left';
      }
      this.textBaseline = 'middle';
      if (textanchor.match('above')) {
        this.textBaseline = 'bottom';
      } else if (textanchor.match('below')) {
        this.textBaseline = 'top';
      }
      return this.fillText(str, x, y);
    }
  };

  RecordableCanvas.prototype._playbackOverridesPdf = {
    _assignments: function(vars) {
      var assgn, getFontString, val, _results;
      getFontString = function(family, weight, style) {
        var ret;
        ret = 'Helvetica';
        family = family != null ? family.toLowerCase() : void 0;
        weight = weight != null ? weight.toLowerCase() : void 0;
        style = style != null ? style.toLowerCase() : void 0;
        if (style === 'oblique') {
          style = 'italic';
        }
        switch (family) {
          case 'times':
          case 'times new roman':
            if (weight === 'bold' && style === 'italic') {
              return ret = 'Times-BoldItalic';
            } else if (weight === 'bold') {
              return ret = 'Times-Bold';
            } else if (style === 'italic') {
              return ret = 'Times-Italic';
            } else {
              return ret = 'Times-Roman';
            }
            break;
          case 'courier':
          case 'monospace':
            if (weight === 'bold' && style === 'italic') {
              return ret = 'Courier-BoldOblique';
            } else if (weight === 'bold') {
              return ret = 'Courier-Bold';
            } else if (style === 'italic') {
              return ret = 'Courier-Oblique';
            } else {
              return ret = 'Courier';
            }
            break;
          default:
            if (weight === 'bold' && style === 'italic') {
              return ret = 'Helvetica-BoldOblique';
            } else if (weight === 'bold') {
              return ret = 'Helvetica-Bold';
            } else if (style === 'italic') {
              return ret = 'Helvetica-Oblique';
            } else {
              return ret = 'Helvetica';
            }
        }
      };
      _results = [];
      for (assgn in vars) {
        val = vars[assgn];
        switch (assgn) {
          case 'fillStyle':
            if (val === 'none') {
              val = 'white';
            }
            _results.push(this.fillColor(val));
            break;
          case 'strokeStyle':
            _results.push(this.strokeColor(val));
            break;
          case 'lineWidth':
            _results.push(this.lineWidth(parseFloat(val)));
            break;
          case 'fontSize':
            _results.push(this.fontSize(parseFloat(val)));
            break;
          case 'fontFamily':
            this.desiredFontFamily = val;
            _results.push(this.font(getFontString(this.desiredFontFamily, this.desiredFontWeight, this.desiredFontStyle)));
            break;
          case 'fontWeight':
            this.desiredFontWeight = val;
            _results.push(this.font(getFontString(this.desiredFontFamily, this.desiredFontWeight, this.desiredFontStyle)));
            break;
          case 'fontStyle':
            this.desiredFontStyle = val;
            _results.push(this.font(getFontString(this.desiredFontFamily, this.desiredFontWeight, this.desiredFontStyle)));
            break;
          default:
            _results.push(void 0);
        }
      }
      return _results;
    },
    beginPath: function() {},
    fillRect: function(x, y, w, h) {
      this.moveTo(0, 0);
      this.lineTo(w, 0);
      this.lineTo(w, h);
      this.lineTo(0, h);
      this.closePath();
      return this.fill();
    },
    strokeRect: function(x, y, w, h) {
      this.moveTo(0, 0);
      this.lineTo(w, 0);
      this.lineTo(w, h);
      this.lineTo(0, h);
      this.closePath();
      return this.stroke();
    },
    text: function(str, x, y, textanchor) {
      var offset_x, offset_y, textAlign, textBaseline, textHeight, textWidth;
      textAlign = 'center';
      if (textanchor.match('left')) {
        textAlign = 'right';
      } else if (textanchor.match('right')) {
        textAlign = 'left';
      }
      textBaseline = 'middle';
      if (textanchor.match('above')) {
        textBaseline = 'bottom';
      } else if (textanchor.match('below')) {
        textBaseline = 'top';
      }
      textHeight = this.currentLineHeight();
      textWidth = this.widthOfString(str);
      offset_x = 0;
      offset_y = 0;
      switch (textAlign) {
        case 'right':
          offset_x = -textWidth;
          break;
        case 'center':
          offset_x = -textWidth / 2;
      }
      switch (textBaseline) {
        case 'bottom':
          offset_y = -textHeight;
          break;
        case 'middle':
          offset_y = -textHeight / 2;
      }
      return this.text(str, x + offset_x, y + offset_y);
    }
  };

  RecordableCanvas.prototype._playbackOverridesSvg = {};

  return RecordableCanvas;

})();

window.nAsciiSVG = (function() {
  /*
      # All the useful math functions
  */

  var E, LN10, LN2, LOG10E, LOG2E, PI, SQRT1_2, SQRT2, abs, acos, arccos, arccosh, arccot, arccoth, arccsc, arccsch, arcsec, arcsech, arcsin, arcsinh, arctan, arctanh, arrowhead, asin, atan, atan2, axes, axesstroke, background, border, ceil, circle, cos, cosh, cot, coth, cpi, csc, csch, ctheta, ctx, defaultfontsize, dot, dotradius, e, exp, fill, floor, fontfamily, fontfill, fontsize, fontstroke, fontstyle, fontweight, gridstroke, height, initPicture, line, ln, log, marker, markersize, mathjs, max, min, noaxes, origin, path, pi, plot, pow, random, rect, resetDefaults, round, sec, sech, setBorder, sign, sin, sinh, slopefield, sqrt, stroke, strokewidth, tan, tanh, text, ticklength, toDeviceCoordinates, updatePicture, width, xmax, xmin, xunitlength, ymax, ymin, yunitlength;
  random = Math.random;
  tan = Math.tan;
  min = Math.min;
  PI = Math.PI;
  sqrt = Math.sqrt;
  E = Math.E;
  SQRT1_2 = Math.SQRT1_2;
  ceil = Math.ceil;
  atan2 = Math.atan2;
  cos = Math.cos;
  LN2 = Math.LN2;
  LOG10E = Math.LOG10E;
  exp = Math.exp;
  round = function(n, places) {
    var shift;
    shift = Math.pow(10, places);
    return Math.round(n * shift) / shift;
  };
  atan = Math.atan;
  max = Math.max;
  pow = Math.pow;
  LOG2E = Math.LOG2E;
  log = Math.log;
  LN10 = Math.LN10;
  floor = Math.floor;
  SQRT2 = Math.SQRT2;
  asin = Math.asin;
  acos = Math.acos;
  sin = Math.sin;
  abs = Math.abs;
  cpi = "\u03C0";
  ctheta = "\u03B8";
  pi = Math.PI;
  ln = Math.log;
  e = Math.E;
  sign = function(x) {
    if (x === 0) {
      return 0;
    } else {
      if (x < 0) {
        return -1;
      } else {
        return 1;
      }
    }
  };
  arcsin = Math.asin;
  arccos = Math.acos;
  arctan = Math.atan;
  sinh = function(x) {
    return (Math.exp(x) - Math.exp(-x)) / 2;
  };
  cosh = function(x) {
    return (Math.exp(x) + Math.exp(-x)) / 2;
  };
  tanh = function(x) {
    return (Math.exp(x) - Math.exp(-x)) / (Math.exp(x) + Math.exp(-x));
  };
  arcsinh = function(x) {
    return ln(x + Math.sqrt(x * x + 1));
  };
  arccosh = function(x) {
    return ln(x + Math.sqrt(x * x - 1));
  };
  arctanh = function(x) {
    return ln((1 + x) / (1 - x)) / 2;
  };
  sech = function(x) {
    return 1 / cosh(x);
  };
  csch = function(x) {
    return 1 / sinh(x);
  };
  coth = function(x) {
    return 1 / tanh(x);
  };
  arcsech = function(x) {
    return arccosh(1 / x);
  };
  arccsch = function(x) {
    return arcsinh(1 / x);
  };
  arccoth = function(x) {
    return arctanh(1 / x);
  };
  sec = function(x) {
    return 1 / Math.cos(x);
  };
  csc = function(x) {
    return 1 / Math.sin(x);
  };
  cot = function(x) {
    return 1 / Math.tan(x);
  };
  arcsec = function(x) {
    return arccos(1 / x);
  };
  arccsc = function(x) {
    return arcsin(1 / x);
  };
  arccot = function(x) {
    return arctan(1 / x);
  };
  ctx = null;
  xmin = -5;
  xmax = 5;
  ymin = -5;
  ymax = 5;
  border = 0;
  xunitlength = yunitlength = 1;
  origin = [0, 0];
  width = null;
  height = null;
  fontsize = null;
  fontfamily = 'sans';
  fontstyle = 'normal';
  fontweight = 'normal';
  fontfill = 'black';
  fontstroke = 'none';
  markersize = 4;
  marker = null;
  defaultfontsize = 16;
  stroke = 'black';
  strokewidth = 1;
  background = 'white';
  gridstroke = '#aaaaaa';
  fill = 'none';
  axesstroke = 'black';
  ticklength = 4;
  dotradius = 4;
  resetDefaults = function() {
    xmin = -5;
    xmax = 5;
    ymin = -5;
    ymax = 5;
    border = 0;
    xunitlength = yunitlength = 1;
    origin = [0, 0];
    width = null;
    height = null;
    fontsize = null;
    fontfamily = 'sans';
    fontstyle = 'normal';
    fontweight = 'normal';
    fontfill = 'black';
    fontstroke = 'none';
    markersize = 4;
    marker = null;
    defaultfontsize = 16;
    stroke = 'black';
    strokewidth = 1;
    gridstroke = '#aaaaaa';
    fill = 'yellow';
    axesstroke = 'black';
    return ticklength = 4;
  };
  toDeviceCoordinates = function(p) {
    return [p[0] * xunitlength + origin[0], height - p[1] * yunitlength - origin[1]];
  };
  updatePicture = function(src, target, renderMode) {
    var array_raw, canvas, canvas_ctx, id, svgCanvas;
    if (renderMode == null) {
      renderMode = 'svg';
    }
    resetDefaults();
    if (typeOf(target) === 'string') {
      target = document.getElementById(target);
    }
    width = parseInt(target.getAttribute('width'));
    height = parseInt(target.getAttribute('height'));
    id = target.getAttribute('id');
    ctx = new RecordableCanvas(width, height);
    initPicture();
    array_raw = src;
    array_raw = array_raw.replace(/plot\(\x20*([^\"f\[][^\n\r]+?)\,/g, "plot\(\"$1\",");
    array_raw = array_raw.replace(/plot\(\x20*([^\"f\[][^\n\r]+)\)/g, "plot(\"$1\")");
    array_raw = array_raw.replace(/([0-9])([a-zA-Z])/g, "$1*$2");
    array_raw = array_raw.replace(/\)([\(0-9a-zA-Z])/g, "\)*$1");
    eval(array_raw);
    switch (renderMode) {
      case 'canvas':
        canvas = $("<canvas width='" + width + "' height='" + height + "' id='" + id + "' />")[0];
        canvas_ctx = canvas.getContext('2d');
        ctx.playbackTo(canvas_ctx, 'canvas');
        target.parentNode.replaceChild(canvas, target);
        break;
      case 'svg':
        svgCanvas = new SvgCanvas(width, height);
        ctx.playbackTo(svgCanvas, 'svg');
        svgCanvas._root.setAttribute('id', id);
        target.parentNode.replaceChild(svgCanvas._root, target);
    }
  };
  initPicture = function(x_min, x_max, y_min, y_max) {
    if (y_min == null) {
      y_min = x_min;
    }
    if (y_max == null) {
      y_max = x_max;
    }
    if (x_min != null) {
      xmin = x_min;
    }
    if (x_max != null) {
      xmax = x_max;
    }
    if (y_min != null) {
      ymin = y_min;
    }
    if (y_max != null) {
      ymax = y_max;
    }
    if (xmin >= xmax || ymin >= ymax) {
      throw new Error("Dimensions [" + [xmin, xmax, ymin, ymax] + "] are not valid");
    }
    xunitlength = (width - 2 * border) / (xmax - xmin);
    yunitlength = (height - 2 * border) / (ymax - ymin);
    origin = [-xmin * xunitlength + border, -ymin * yunitlength + border];
    ctx.width = width;
    ctx.height = height;
    return noaxes();
  };
  text = function(pos, str, textanchor, angle, padding) {
    var computed_fontsize, p, padding_x, padding_y;
    if (textanchor == null) {
      textanchor = 'center';
    }
    if (angle == null) {
      angle = 0;
    }
    if (padding == null) {
      padding = 4;
    }
    computed_fontsize = fontsize || defaultfontsize;
    p = toDeviceCoordinates(pos);
    if (angle !== 0) {
      throw new Error('rotations not yet supported');
      ctx.rotate(angle / (2 * pi));
    }
    padding_x = 0;
    padding_y = 0;
    if (textanchor.match('left')) {
      if (padding > 0) {
        padding_x -= padding + 3;
      }
    }
    if (textanchor.match('right')) {
      if (padding > 0) {
        padding_x += padding + 3;
      }
    }
    if (textanchor.match('above')) {
      padding_y -= padding;
    }
    if (textanchor.match('below')) {
      padding_y += padding;
    }
    ctx.font = "" + fontstyle + " " + fontweight + " " + computed_fontsize + "px " + fontfamily;
    ctx.fontFamily = fontfamily;
    ctx.fontSize = computed_fontsize;
    ctx.fontWeight = fontweight;
    ctx.fontStyle = fontstyle;
    ctx.fillStyle = fontfill;
    ctx.text(str, p[0] + padding_x, p[1] + padding_y, textanchor);
    return pos;
  };
  setBorder = function(width, color) {
    if (width != null) {
      border = width;
    }
    if (color != null) {
      return stroke = color;
    }
  };
  noaxes = function() {
    ctx.fillStyle = background;
    return ctx.fillRect(0, 0, width, height);
  };
  axes = function(dx, dy, labels, griddx, griddy, units) {
    var labeldecimals_x, labeldecimals_y, labelplacement_x, labelplacement_y, labelposition_x, labelposition_y, p, padding, tickdx, tickdy, x, xunits, y, yunits;
    tickdx = dx != null ? dx * xunitlength : xunitlength;
    tickdy = dy != null ? dy * yunitlength : yunitlength;
    fontsize = fontsize || min(tickdx / 2, tickdy / 2, 16);
    if (typeOf(griddx) === 'number' && griddy === void 0) {
      griddy = griddx;
    }
    if ((griddx != null) || (griddy != null)) {
      ctx.beginPath();
      ctx.strokeStyle = gridstroke;
      ctx.lineWidth = 0.5;
      ctx.fillStyle = fill;
      if ((griddx != null) && griddx > 0) {
        x = ceil(xmin / griddx) * griddx;
        while (x < xmax) {
          p = toDeviceCoordinates([x, 0]);
          ctx.moveTo(p[0], 0);
          ctx.lineTo(p[0], height);
          x += griddx;
        }
      }
      if ((griddy != null) && griddy > 0) {
        y = ceil(ymin / griddy) * griddy;
        while (y < ymax) {
          p = toDeviceCoordinates([0, y]);
          ctx.moveTo(0, p[1]);
          ctx.lineTo(width, p[1]);
          y += griddy;
        }
      }
      ctx.stroke();
    }
    if ((dx != null) || (dy != null)) {
      ctx.beginPath();
      ctx.strokeStyle = axesstroke;
      ctx.fillStyle = fill;
      ctx.lineWidth = 1;
      p = toDeviceCoordinates([0, 0]);
      ctx.moveTo(0, p[1]);
      ctx.lineTo(width, p[1]);
      ctx.moveTo(p[0], 0);
      ctx.lineTo(p[0], height);
      if ((dx != null) && dx > 0) {
        x = ceil(xmin / dx) * dx;
        while (x < xmax) {
          if (x === 0) {
            x += dx;
          }
          p = toDeviceCoordinates([x, 0]);
          ctx.moveTo(p[0], p[1] - ticklength);
          ctx.lineTo(p[0], p[1] + ticklength);
          x += dx;
        }
      }
      if ((dy != null) && dy > 0) {
        y = ceil(ymin / dy) * dy;
        while (y < ymax) {
          if (y === 0) {
            y += dy;
          }
          p = toDeviceCoordinates([0, y]);
          ctx.moveTo(p[0] - ticklength, p[1]);
          ctx.lineTo(p[0] + ticklength, p[1]);
          y += dy;
        }
      }
      ctx.stroke();
    }
    if (labels != null) {
      xunits = yunits = '';
      labeldecimals_x = floor(1.1 - log(dx)) + 1;
      labeldecimals_y = floor(1.1 - log(dy)) + 1;
      padding = 2 * ticklength / yunitlength;
      labelposition_x = ymin > 0 || ymax < 0 ? ymin + padding : -padding;
      padding = 2 * ticklength / xunitlength;
      labelposition_y = xmin > 0 || xmax < 0 ? xmin + padding : -padding;
      labelplacement_x = ymin > 0 || ymax < 0 ? 'above' : 'below';
      labelplacement_y = xmin > 0 || xmax < 0 ? 'right' : 'left';
      x = ceil(xmin / dx) * dx;
      while (x < xmax) {
        if (x === 0) {
          x += dx;
        }
        text([x, labelposition_x], "" + (round(x, labeldecimals_x)) + xunits, labelplacement_x);
        x += dx;
      }
      y = ceil(ymin / dy) * dy;
      while (y < ymax) {
        if (y === 0) {
          y += dy;
        }
        text([labelposition_y, y], "" + (round(y, labeldecimals_y)) + yunits, labelplacement_y);
        y += dy;
      }
    }
  };
  rect = function(corner1, corner2) {
    corner1 = toDeviceCoordinates(corner1);
    corner2 = toDeviceCoordinates(corner2);
    ctx.beginPath();
    ctx.moveTo(corner1[0], corner1[1]);
    ctx.lineTo(corner1[0], corner2[1]);
    ctx.lineTo(corner2[0], corner2[1]);
    ctx.lineTo(corner2[0], corner1[1]);
    ctx.closePath();
    ctx.fillStyle = fill;
    ctx.strokeStyle = stroke;
    if ((fill != null) && fill !== 'none') {
      return ctx.fillAndStroke();
    } else {
      return ctx.stroke();
    }
  };
  circle = function(center, radius, filled) {
    var p;
    if (filled == null) {
      filled = false;
    }
    p = toDeviceCoordinates(center);
    radius = radius * xunitlength;
    ctx.beginPath();
    ctx.lineWidth = strokewidth;
    ctx.strokeStyle = stroke;
    ctx.fillStyle = fill;
    ctx.circle(p[0], p[1], radius);
    if (filled) {
      ctx.fillAndStroke();
    } else {
      ctx.stroke();
    }
  };
  dot = function(center, type, label, textanchor, angle) {
    var p, prevFill;
    if (textanchor == null) {
      textanchor = 'below';
    }
    p = toDeviceCoordinates(center);
    ctx.strokeStyle = stroke;
    ctx.lineWidth = strokewidth;
    switch (type) {
      case '+':
        ctx.beginPath();
        ctx.moveTo(p[0] - ticklength, p[1]);
        ctx.lineTo(p[0] + ticklength, p[1]);
        ctx.moveTo(p[0], p[1] - ticklength);
        ctx.lineTo(p[0], p[1] + ticklength);
        ctx.stroke();
        break;
      case '-':
        ctx.beginPath();
        ctx.moveTo(p[0] - ticklength, p[1]);
        ctx.lineTo(p[0] + ticklength, p[1]);
        ctx.stroke();
        break;
      case '|':
        ctx.beginPath();
        ctx.moveTo(p[0], p[1] - ticklength);
        ctx.lineTo(p[0], p[1] + ticklength);
        ctx.stroke();
        break;
      default:
        prevFill = fill;
        if (type != null ? type.match('open') : void 0) {
          fill = background;
        } else if (type != null ? type.match('closed') : void 0) {
          fill = stroke;
        }
        circle(center, dotradius / xunitlength, true);
        fill = prevFill;
    }
    if (label != null) {
      return text(center, label, textanchor, angle, dotradius + 1);
    }
  };
  arrowhead = function(p, q, size) {
    var d, u, uperp;
    if (size == null) {
      size = markersize;
    }
    p = toDeviceCoordinates(p);
    q = toDeviceCoordinates(q);
    u = [p[0] - q[0], p[1] - q[1]];
    d = Math.sqrt(u[0] * u[0] + u[1] * u[1]);
    if (d > 1e-7) {
      u = [-u[0] / d, -u[1] / d];
      uperp = [-u[1], u[0]];
      ctx.lineWidth = size;
      ctx.strokeStyle = stroke;
      ctx.fillStyle = stroke;
      ctx.beginPath();
      ctx.moveTo(q[0] - 15 * u[0] - 4 * uperp[0], q[1] - 15 * u[1] - 4 * uperp[1]);
      ctx.lineTo(q[0] - 3 * u[0], q[1] - 3 * u[1]);
      ctx.lineTo(q[0] - 15 * u[0] + 4 * uperp[0], q[1] - 15 * u[1] + 4 * uperp[1]);
      ctx.closePath();
      ctx.fillAndStroke();
    }
  };
  line = function(p, q) {
    var u, v;
    u = toDeviceCoordinates(p);
    v = toDeviceCoordinates(q);
    ctx.beginPath();
    ctx.lineWidth = strokewidth;
    ctx.strokeStyle = stroke;
    ctx.fillStyle = fill;
    ctx.moveTo(u[0], u[1]);
    ctx.lineTo(v[0], v[1]);
    ctx.stroke();
    if (marker === 'dot' || marker === 'arrowdot') {
      dot(p);
      if (marker === 'arrowdot') {
        arrowhead(p, q);
      }
      return dot(q);
    }
  };
  path = function(plist) {
    var p, _i, _j, _len, _len1, _ref;
    p = toDeviceCoordinates(plist[0]);
    ctx.beginPath();
    ctx.lineWidth = strokewidth;
    ctx.strokeStyle = stroke;
    ctx.fillStyle = fill;
    ctx.moveTo(p[0], p[1]);
    _ref = plist.slice(1);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      p = _ref[_i];
      p = toDeviceCoordinates(p);
      ctx.lineTo(p[0], p[1]);
    }
    ctx.stroke();
    if (marker === 'dot' || marker === 'arrowdot') {
      for (_j = 0, _len1 = plist.length; _j < _len1; _j++) {
        p = plist[_j];
        dot(p);
      }
    }
  };
  plot = function(func, x_min, x_max, samples) {
    var f, g, i, inbounds, inc, p, pInBounds, pNext, pPrevious, paths, points, t, threshold, toFunc, workingPath, _i, _j, _k, _len, _len1;
    if (x_min == null) {
      x_min = xmin;
    }
    if (x_max == null) {
      x_max = xmax;
    }
    if (samples == null) {
      samples = 200;
    }
    toFunc = function(func) {
      var ret;
      switch (typeOf(func)) {
        case 'string':
          ret = null;
          eval("ret = function(x){ return " + (mathjs(func)) + " }");
          break;
        case 'function':
          ret = func;
          break;
        default:
          throw new Error("Unknown function type '" + func + "'");
      }
      return ret;
    };
    threshold = function(x) {
      var plotDiameter;
      plotDiameter = max(1e-6, ymax - ymin, xmax - xmin);
      return min(max(x, ymin - plotDiameter * 100), ymax + plotDiameter * 100);
    };
    f = function(x) {
      return x;
    };
    g = null;
    switch (typeOf(func)) {
      case 'string':
      case 'function':
        g = toFunc(func);
        break;
      case 'array':
        f = toFunc(func[0]);
        g = toFunc(func[1]);
        break;
      default:
        throw new Error("Unknown function type '" + func + "'");
    }
    points = [];
    inc = max(0.0000001, (x_max - x_min) / samples);
    for (t = _i = x_min; x_min <= x_max ? _i <= x_max : _i >= x_max; t = _i += inc) {
      p = [threshold(f(t)), threshold(g(t))];
      if (isNaN(p[0]) === false && isNaN(p[1]) === false) {
        points.push(p);
      }
    }
    inbounds = function(p) {
      if (p[1] > ymin && p[1] < ymax && p[0] > xmin && p[0] < xmax) {
        return true;
      }
      return false;
    };
    paths = [];
    workingPath = [];
    for (i = _j = 0, _len = points.length; _j < _len; i = ++_j) {
      p = points[i];
      pNext = points[i + 1];
      pPrevious = points[i - 1];
      pInBounds = inbounds(p);
      if (pNext && pInBounds === false && inbounds(pNext) === true) {
        paths.push(workingPath);
        workingPath = [];
        workingPath.push(p);
      } else if (pPrevious && pInBounds === false && inbounds(pPrevious) === true) {
        workingPath.push(p);
        paths.push(workingPath);
        workingPath = [];
      } else if (pInBounds) {
        workingPath.push(p);
      }
    }
    paths.push(workingPath);
    for (_k = 0, _len1 = paths.length; _k < _len1; _k++) {
      p = paths[_k];
      if (p.length > 0) {
        path(p);
      }
    }
  };
  slopefield = function(func, dx, dy) {
    var dz, g, gxy, l, pointList, u, v, x, x_min, y, y_min, _i, _j, _k, _len;
    if (dx == null) {
      dx = 1;
    }
    if (dy == null) {
      dy = 1;
    }
    g = func;
    if (typeOf(func) === 'string') {
      eval("g = function(x,y){ return " + (mathjs(func)) + " }");
    }
    dz = sqrt(dx * dx + dy * dy) / 4;
    x_min = ceil(xmin / dx) * dx;
    y_min = ceil(ymin / dy) * dy;
    pointList = [];
    for (x = _i = x_min; x_min <= xmax ? _i <= xmax : _i >= xmax; x = _i += dx) {
      for (y = _j = y_min; y_min <= ymax ? _j <= ymax : _j >= ymax; y = _j += dy) {
        gxy = g(x, y);
        if (!isNaN(gxy)) {
          if (abs(gxy) === Infinity) {
            u = 0;
            v = dz;
          } else {
            u = dz / sqrt(1 + gxy * gxy);
            v = gxy * u;
          }
          if ((xmin <= x && x <= xmax) && (ymin <= y && y <= ymax)) {
            pointList.push([[x - u, y - v], [x + u, y + v]]);
          }
        }
      }
    }
    for (_k = 0, _len = pointList.length; _k < _len; _k++) {
      l = pointList[_k];
      line(l[0], l[1]);
    }
  };
  mathjs = function(st) {
    var ch, i, j, k, nested;
    st = st.replace(/\s/g, "");
    if (st.indexOf("^-1") !== -1) {
      st = st.replace(/sin\^-1/g, "arcsin");
      st = st.replace(/cos\^-1/g, "arccos");
      st = st.replace(/tan\^-1/g, "arctan");
      st = st.replace(/sec\^-1/g, "arcsec");
      st = st.replace(/csc\^-1/g, "arccsc");
      st = st.replace(/cot\^-1/g, "arccot");
      st = st.replace(/sinh\^-1/g, "arcsinh");
      st = st.replace(/cosh\^-1/g, "arccosh");
      st = st.replace(/tanh\^-1/g, "arctanh");
      st = st.replace(/sech\^-1/g, "arcsech");
      st = st.replace(/csch\^-1/g, "arccsch");
      st = st.replace(/coth\^-1/g, "arccoth");
    }
    st = st.replace(/^e$/g, "(E)");
    st = st.replace(/^e([^a-zA-Z])/g, "(E)$1");
    st = st.replace(/([^a-zA-Z])e([^a-zA-Z])/g, "$1(E)$2");
    st = st.replace(/([0-9])([\(a-zA-Z])/g, "$1*$2");
    st = st.replace(/\)([\(0-9a-zA-Z])/g, ")*$1");
    i = void 0;
    j = void 0;
    k = void 0;
    ch = void 0;
    nested = void 0;
    while ((i = st.indexOf("^")) !== -1) {
      if (i === 0) {
        throw new Error("missing argument for '^'");
      }
      j = i - 1;
      ch = st.charAt(j);
      if (ch >= "0" && ch <= "9") {
        j--;
        while (j >= 0 && (ch = st.charAt(j)) >= "0" && ch <= "9") {
          j--;
        }
        if (ch === ".") {
          j--;
          while (j >= 0 && (ch = st.charAt(j)) >= "0" && ch <= "9") {
            j--;
          }
        }
      } else if (ch === ")") {
        nested = 1;
        j--;
        while (j >= 0 && nested > 0) {
          ch = st.charAt(j);
          if (ch === "(") {
            nested--;
          } else {
            if (ch === ")") {
              nested++;
            }
          }
          j--;
        }
        while (j >= 0 && (ch = st.charAt(j)) >= "a" && ch <= "z" || ch >= "A" && ch <= "Z") {
          j--;
        }
      } else if (ch >= "a" && ch <= "z" || ch >= "A" && ch <= "Z") {
        j--;
        while (j >= 0 && (ch = st.charAt(j)) >= "a" && ch <= "z" || ch >= "A" && ch <= "Z") {
          j--;
        }
      } else {
        throw new Error("incorrect syntax in " + st + " at position " + j);
      }
      if (i === st.length - 1) {
        throw new Error("missing argument");
      }
      k = i + 1;
      ch = st.charAt(k);
      if (ch >= "0" && ch <= "9" || ch === "-") {
        k++;
        while (k < st.length && (ch = st.charAt(k)) >= "0" && ch <= "9") {
          k++;
        }
        if (ch === ".") {
          k++;
          while (k < st.length && (ch = st.charAt(k)) >= "0" && ch <= "9") {
            k++;
          }
        }
      } else if (ch === "(") {
        nested = 1;
        k++;
        while (k < st.length && nested > 0) {
          ch = st.charAt(k);
          if (ch === "(") {
            nested++;
          } else {
            if (ch === ")") {
              nested--;
            }
          }
          k++;
        }
      } else if (ch >= "a" && ch <= "z" || ch >= "A" && ch <= "Z") {
        k++;
        while (k < st.length && (ch = st.charAt(k)) >= "a" && ch <= "z" || ch >= "A" && ch <= "Z") {
          k++;
        }
      } else {
        throw new Error("incorrect syntax in " + st + " at position " + k);
      }
      st = st.slice(0, j + 1) + "pow(" + st.slice(j + 1, i) + "," + st.slice(i + 1, k) + ")" + st.slice(k);
    }
    while ((i = st.indexOf("!")) !== -1) {
      if (i === 0) {
        throw new Error("missing argument for '!'");
      }
      j = i - 1;
      ch = st.charAt(j);
      if (ch >= "0" && ch <= "9") {
        j--;
        while (j >= 0 && (ch = st.charAt(j)) >= "0" && ch <= "9") {
          j--;
        }
        if (ch === ".") {
          j--;
          while (j >= 0 && (ch = st.charAt(j)) >= "0" && ch <= "9") {
            j--;
          }
        }
      } else if (ch === ")") {
        nested = 1;
        j--;
        while (j >= 0 && nested > 0) {
          ch = st.charAt(j);
          if (ch === "(") {
            nested--;
          } else {
            if (ch === ")") {
              nested++;
            }
          }
          j--;
        }
        while (j >= 0 && (ch = st.charAt(j)) >= "a" && ch <= "z" || ch >= "A" && ch <= "Z") {
          j--;
        }
      } else if (ch >= "a" && ch <= "z" || ch >= "A" && ch <= "Z") {
        j--;
        while (j >= 0 && (ch = st.charAt(j)) >= "a" && ch <= "z" || ch >= "A" && ch <= "Z") {
          j--;
        }
      } else {
        throw new Error("incorrect syntax in " + st + " at position " + j);
      }
      st = st.slice(0, j + 1) + "factorial(" + st.slice(j + 1, i) + ")" + st.slice(i + 1);
    }
    return st;
  };
  return {
    updatePicture: updatePicture,
    initPicture: initPicture,
    ctx: (function() {
      return ctx;
    }),
    axes: axes,
    plot: plot
  };
})();
