// Generated by CoffeeScript 1.3.3
/*
# Reimplimentation of the asciisvg api
#
# (c) Jason Siefken
# GPL 3
*/

/*
# Smart typeof function that will recognize builtin types as well as objects
# that are instances of those types.
*/

var AsciiSVG, MathFunctions, RecordableCanvas, SourceModifier, SvgCanvas, typeOf,
  __slice = [].slice;

typeOf = window.typeOf || function(obj) {
  var constructor, constructorName, guess, objectTypes, type;
  guess = typeof obj;
  if (guess !== 'object') {
    return guess;
  }
  if (obj === null) {
    return 'null';
  }
  objectTypes = {
    'array': Array,
    'boolean': Boolean,
    'number': Number,
    'string': String
  };
  for (type in objectTypes) {
    constructor = objectTypes[type];
    if (obj instanceof constructor) {
      return type;
    }
  }
  constructorName = obj.constructor.name;
  if (constructorName === 'Object' || !(constructorName != null)) {
    return 'object';
  }
  return constructorName;
};

/*
# Acts like a canvas, but canvas commands are converted into svg commands
*/


SvgCanvas = (function() {
  var KAPPA, createSvgNode;

  KAPPA = 4.0 * ((Math.sqrt(2) - 1.0) / 3.0);

  createSvgNode = function(tag) {
    return document.createElementNS('http://www.w3.org/2000/svg', tag);
  };

  function SvgCanvas(width, height) {
    this.width = width != null ? width : 550;
    this.height = height != null ? height : 450;
    this._root = createSvgNode('svg');
    this._root.setAttribute("width", this.width);
    this._root.setAttribute("height", this.height);
    this._currentGroup = this._root;
    this._currentPath = '';
  }

  SvgCanvas.prototype.moveTo = function(x, y) {
    return this._currentPath += "M" + x + "," + y + " ";
  };

  SvgCanvas.prototype.lineTo = function(x, y) {
    return this._currentPath += "L" + x + "," + y + " ";
  };

  SvgCanvas.prototype.bezierCurveTo = function(cp1x, cp1y, cp2x, cp2y, x, y) {
    return this._currentPath += "C" + cp1x + "," + cp1y + "," + cp2x + "," + cp2y + "," + x + "," + y + " ";
  };

  SvgCanvas.prototype.quadraticCurveTo = function(cpx, cpy, x, y) {
    return this._currentPath += "Q" + cpx + "," + cpy + "," + x + "," + y + " ";
  };

  SvgCanvas.prototype.closePath = function() {
    return this._currentPath += "Z";
  };

  SvgCanvas.prototype.beginPath = function() {
    return this._currentPath = '';
  };

  SvgCanvas.prototype.text = function(str, x, y, textanchor) {
    var dy, fontsize, node;
    this.textBaseline = 'middle';
    this.textAnchor = 'middle';
    if (textanchor.match('left')) {
      this.textAnchor = 'end';
    } else if (textanchor.match('right')) {
      this.textAnchor = 'start';
    }
    this.textBaseline = 'middle';
    if (textanchor.match('above')) {
      this.textBaseline = 'bottom';
    } else if (textanchor.match('below')) {
      this.textBaseline = 'top';
    }
    fontsize = parseFloat(this.fontsize) || 16;
    dy = -fontsize / 4;
    switch (this.textBaseline) {
      case 'top':
        dy = fontsize;
        break;
      case 'middle':
        dy = fontsize / 2;
    }
    node = createSvgNode("text");
    node.setAttribute("x", x);
    node.setAttribute("y", y + dy);
    node.setAttribute("fill", this.fillStyle);
    if (this.fontFamily) {
      node.setAttribute("font-family", this.fontFamily);
    }
    if (this.fontWeight) {
      node.setAttribute("font-weight", this.fontWeight);
    }
    if (this.fontStyle) {
      node.setAttribute("font-style", this.fontStyle);
    }
    if (this.fontSize) {
      node.setAttribute("font-size", this.fontSize);
    }
    node.setAttribute("text-anchor", this.textAnchor);
    node.appendChild(document.createTextNode(str));
    return this._currentGroup.appendChild(node);
  };

  SvgCanvas.prototype.stroke = function() {
    var node, _ref;
    node = createSvgNode("path");
    node.setAttribute("d", this._currentPath);
    node.setAttribute("fill", "none");
    node.setAttribute("stroke", this.strokeStyle);
    node.setAttribute("stroke-width", this.lineWidth);
    if (this.lineJoin) {
      node.setAttribute("stroke-linejoin", this.lineJoin);
    }
    if (this.lineCap) {
      node.setAttribute("stroke-linecap", this.lineCap);
    }
    if ((this.mozDash != null) && ((_ref = this.mozDash) != null ? _ref[1] : void 0) !== 0) {
      node.setAttribute("stroke-dasharray", this.mozDash.join(','));
    }
    return this._currentGroup.appendChild(node);
  };

  SvgCanvas.prototype.fill = function() {
    var node;
    node = createSvgNode("path");
    node.setAttribute("d", this._currentPath);
    node.setAttribute("fill", this.fillStyle);
    return this._currentGroup.appendChild(node);
  };

  SvgCanvas.prototype.fillAndStroke = function() {
    var node, _ref;
    node = createSvgNode("path");
    node.setAttribute("d", this._currentPath);
    node.setAttribute("fill", this.fillStyle);
    node.setAttribute("stroke", this.strokeStyle);
    node.setAttribute("stroke-width", this.lineWidth);
    if (this.lineJoin) {
      node.setAttribute("stroke-linejoin", this.lineJoin);
    }
    if ((this.mozDash != null) && ((_ref = this.mozDash) != null ? _ref[1] : void 0) !== 0) {
      node.setAttribute("stroke-dasharray", this.mozDash.join(','));
    }
    return this._currentGroup.appendChild(node);
  };

  SvgCanvas.prototype.fillRect = function(x, y, w, h) {
    var node;
    node = createSvgNode("rect");
    node.setAttribute("x", x);
    node.setAttribute("y", y);
    node.setAttribute("width", w);
    node.setAttribute("height", h);
    node.setAttribute("fill", this.fillStyle);
    return this._currentGroup.appendChild(node);
  };

  SvgCanvas.prototype.strokeRect = function(x, y, w, h) {
    var node, _ref;
    node = createSvgNode("path");
    node.setAttribute("x", x);
    node.setAttribute("y", y);
    node.setAttribute("width", w);
    node.setAttribute("height", h);
    node.setAttribute("stroke", this.strokeStyle);
    node.setAttribute("stroke-width", this.lineWidth);
    if ((this.mozDash != null) && ((_ref = this.mozDash) != null ? _ref[1] : void 0) !== 0) {
      node.setAttribute("stroke-dasharray", this.mozDash.join(','));
    }
    return this._currentGroup.appendChild(node);
  };

  SvgCanvas.prototype.circle = function(x, y, r) {
    return this.ellipse(x, y, r);
  };

  SvgCanvas.prototype.ellipse = function(x, y, r1, r2) {
    var l1, l2;
    if (r2 == null) {
      r2 = r1;
    }
    l1 = r1 * KAPPA;
    l2 = r2 * KAPPA;
    this.moveTo(x + r1, y);
    this.bezierCurveTo(x + r1, y + l1, x + l2, y + r2, x, y + r2);
    this.bezierCurveTo(x - l2, y + r2, x - r1, y + l1, x - r1, y);
    this.bezierCurveTo(x - r1, y - l1, x - l2, y - r2, x, y - r2);
    this.bezierCurveTo(x + l2, y - r2, x + r1, y - l1, x + r1, y);
    return this.moveTo(x, y);
  };

  SvgCanvas.prototype.scale = function(x, y) {
    var node;
    node = createSvgNode('g');
    node.setAttribute("transform", "scale(" + x + "," + y + ")");
    this._currentGroup.appendChild(node);
    return this._currentGroup = node;
  };

  SvgCanvas.prototype.rotate = function(angle) {
    var node;
    node = createSvgNode('g');
    node.setAttribute("transform", "rotate(" + angle + ")");
    this._currentGroup.appendChild(node);
    return this._currentGroup = node;
  };

  SvgCanvas.prototype.translate = function(x, y) {
    var node;
    node = createSvgNode('g');
    node.setAttribute("transform", "translate(" + x + "," + y + ")");
    this._currentGroup.appendChild(node);
    return this._currentGroup = node;
  };

  SvgCanvas.prototype.transform = function(m11, m12, m21, m22, dx, dy) {
    var node;
    node = createSvgNode('g');
    node.setAttribute("transform", "matrix(" + m11 + "," + m22 + "," + m21 + "," + m22 + "," + dx + "," + dy + ")");
    this._currentGroup.appendChild(node);
    return this._currentGroup = node;
  };

  SvgCanvas.prototype.save = function() {
    return this._savedNode = this._currentGroup;
  };

  SvgCanvas.prototype.restore = function() {
    return this._currentGroup = this._savedNode;
  };

  return SvgCanvas;

})();

/*
# Acts like a canvas context, but when issued a drawing
# command, it saves the operation and the state of lineWidth/etc...
# so that it can be replayed to an actual canvas context
*/


RecordableCanvas = (function() {
  var filterStateChanges, makeRecordable, objDiff;

  makeRecordable = function(funcName, parent) {
    return parent[funcName] = function() {
      var args, prop, state, _i, _len, _ref;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      state = {};
      _ref = parent._satefulVariables;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        prop = _ref[_i];
        state[prop] = parent[prop];
      }
      parent._issuedCommands.push({
        command: funcName,
        args: args,
        state: state
      });
    };
  };

  objDiff = function(a, b) {
    var prop, ret;
    ret = {};
    for (prop in b) {
      if ((a[prop] !== b[prop]) || (b[prop] === void 0 && a[prop] !== void 0)) {
        ret[prop] = b[prop];
      }
    }
    return ret;
  };

  filterStateChanges = function(ops) {
    var assgn, changedState, cmd, i, newCmd, prevCmd, ret, val, _i, _ref, _ref1;
    ret = [];
    if (ops.length === 0) {
      return ret;
    }
    newCmd = {
      state: {}
    };
    cmd = ops[0];
    newCmd['command'] = cmd['command'];
    newCmd['args'] = cmd['args'];
    _ref = cmd['state'];
    for (assgn in _ref) {
      val = _ref[assgn];
      if (val != null) {
        newCmd['state'][assgn] = val;
      }
    }
    ret.push(newCmd);
    for (i = _i = 1, _ref1 = ops.length; 1 <= _ref1 ? _i < _ref1 : _i > _ref1; i = 1 <= _ref1 ? ++_i : --_i) {
      prevCmd = ops[i - 1];
      cmd = ops[i];
      changedState = objDiff(prevCmd['state'], cmd['state']);
      newCmd = {
        state: {}
      };
      newCmd['command'] = cmd['command'];
      newCmd['args'] = cmd['args'];
      for (assgn in changedState) {
        val = changedState[assgn];
        newCmd['state'][assgn] = val;
      }
      ret.push(newCmd);
    }
    return ret;
  };

  function RecordableCanvas(width, height) {
    var cmd, _i, _len, _ref;
    this.width = width;
    this.height = height;
    this._satefulVariables = ['lineWidth', 'lineCap', 'miterLimit', 'strokeStyle', 'fillStyle', 'textAlign', 'textBaseline', 'globalAlpha', 'font', 'fontFamily', 'fontSize', 'fontWeight', 'fontStyle', 'mozDash'];
    this._ctxCommands = ['scale', 'rotate', 'translate', 'transform', 'beginPath', 'closePath', 'fill', 'stroke', 'clip', 'moveTo', 'lineTo', 'quadraticCurveTo', 'bezierCurveTo', 'arcTo', 'arc', 'rect', 'text', 'strokeText', 'clearRect', 'fillRect', 'strokeRect', 'fillAndStroke', 'circle', 'save', 'restore'];
    _ref = this._ctxCommands;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      cmd = _ref[_i];
      makeRecordable(cmd, this);
    }
    this._issuedCommands = [];
  }

  RecordableCanvas.prototype.playbackTo = function(ctx, mode) {
    var assgn, cmd, ret, s, val, wrap, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6;
    if (mode == null) {
      mode = 'string';
    }
    switch (mode.toLowerCase()) {
      case 'string':
        wrap = function(s) {
          if (typeof s === 'string') {
            return "'" + s + "'";
          } else {
            return s;
          }
        };
        ret = [];
        _ref = filterStateChanges(this._issuedCommands);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          cmd = _ref[_i];
          _ref1 = cmd['state'];
          for (assgn in _ref1) {
            val = _ref1[assgn];
            ret.push("ctx." + assgn + " = " + (wrap(val)) + ";");
          }
          ret.push("ctx." + cmd['command'] + "(" + (((function() {
            var _j, _len1, _ref2, _results;
            _ref2 = cmd['args'];
            _results = [];
            for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
              s = _ref2[_j];
              _results.push(wrap(s));
            }
            return _results;
          })()).join(', ')) + ");");
        }
        ret = ret.join('\n');
        break;
      case 'canvas':
        _ref2 = filterStateChanges(this._issuedCommands);
        for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
          cmd = _ref2[_j];
          _ref3 = cmd['state'];
          for (assgn in _ref3) {
            val = _ref3[assgn];
            ctx[assgn] = val;
          }
          try {
            if (cmd['command'] in this._playbackOverridesCanvas) {
              this._playbackOverridesCanvas[cmd['command']].apply(ctx, cmd['args']);
            } else {
              ctx[cmd['command']].apply(ctx, cmd['args']);
            }
          } catch (e) {
            console.log(e, cmd['command'], cmd['args']);
          }
        }
        ret = null;
        break;
      case 'pdf':
        _ref4 = filterStateChanges(this._issuedCommands);
        for (_k = 0, _len2 = _ref4.length; _k < _len2; _k++) {
          cmd = _ref4[_k];
          try {
            this._playbackOverridesPdf._assignments.call(ctx, cmd['state']);
            if (cmd['command'] in this._playbackOverridesPdf) {
              this._playbackOverridesPdf[cmd['command']].apply(ctx, cmd['args']);
            } else {
              ctx[cmd['command']].apply(ctx, cmd['args']);
            }
          } catch (e) {
            console.log(e, cmd['command'], cmd['args']);
          }
        }
        ret = ctx;
        break;
      case 'svg':
        _ref5 = filterStateChanges(this._issuedCommands);
        for (_l = 0, _len3 = _ref5.length; _l < _len3; _l++) {
          cmd = _ref5[_l];
          _ref6 = cmd['state'];
          for (assgn in _ref6) {
            val = _ref6[assgn];
            ctx[assgn] = val;
          }
          try {
            if (cmd['command'] in this._playbackOverridesSvg) {
              this._playbackOverridesSvg[cmd['command']].apply(ctx, cmd['args']);
            } else {
              ctx[cmd['command']].apply(ctx, cmd['args']);
            }
          } catch (e) {
            console.log(e, cmd['command'], cmd['args']);
          }
        }
        ret = ctx;
        break;
      default:
        throw new Error("Unknown mode " + mode);
    }
    return ret;
  };

  RecordableCanvas.prototype._playbackOverridesCanvas = {
    circle: function(x, y, radius) {
      return this.arc(x, y, radius, 0, 2 * Math.PI, false);
    },
    fillAndStroke: function() {
      this.fill();
      return this.stroke();
    },
    text: function(str, x, y, textanchor) {
      this.textAlign = 'center';
      if (textanchor.match('left')) {
        this.textAlign = 'right';
      } else if (textanchor.match('right')) {
        this.textAlign = 'left';
      }
      this.textBaseline = 'middle';
      if (textanchor.match('above')) {
        this.textBaseline = 'bottom';
      } else if (textanchor.match('below')) {
        this.textBaseline = 'top';
      }
      return this.fillText(str, x, y);
    }
  };

  RecordableCanvas.prototype._playbackOverridesPdf = {
    _assignments: function(vars) {
      var assgn, getFontString, val, _results;
      getFontString = function(family, weight, style) {
        var ret;
        ret = 'Helvetica';
        family = family != null ? family.toLowerCase() : void 0;
        weight = weight != null ? weight.toLowerCase() : void 0;
        style = style != null ? style.toLowerCase() : void 0;
        if (style === 'oblique') {
          style = 'italic';
        }
        switch (family) {
          case 'times':
          case 'times new roman':
            if (weight === 'bold' && style === 'italic') {
              return ret = 'Times-BoldItalic';
            } else if (weight === 'bold') {
              return ret = 'Times-Bold';
            } else if (style === 'italic') {
              return ret = 'Times-Italic';
            } else {
              return ret = 'Times-Roman';
            }
            break;
          case 'courier':
          case 'monospace':
            if (weight === 'bold' && style === 'italic') {
              return ret = 'Courier-BoldOblique';
            } else if (weight === 'bold') {
              return ret = 'Courier-Bold';
            } else if (style === 'italic') {
              return ret = 'Courier-Oblique';
            } else {
              return ret = 'Courier';
            }
            break;
          default:
            if (weight === 'bold' && style === 'italic') {
              return ret = 'Helvetica-BoldOblique';
            } else if (weight === 'bold') {
              return ret = 'Helvetica-Bold';
            } else if (style === 'italic') {
              return ret = 'Helvetica-Oblique';
            } else {
              return ret = 'Helvetica';
            }
        }
      };
      _results = [];
      for (assgn in vars) {
        val = vars[assgn];
        switch (assgn) {
          case 'fillStyle':
            if (val === 'none') {
              val = 'white';
            }
            _results.push(this.fillColor(val));
            break;
          case 'strokeStyle':
            _results.push(this.strokeColor(val));
            break;
          case 'mozDash':
            if (val != null) {
              if (val.length === 1) {
                _results.push(this.dash(val[0]));
              } else if (val[1] > 0) {
                _results.push(this.dash(val[0], {
                  space: val[1]
                }));
              } else {
                _results.push(this.undash());
              }
            } else {
              _results.push(this.undash());
            }
            break;
          case 'lineWidth':
            _results.push(this.lineWidth(parseFloat(val)));
            break;
          case 'fontSize':
            _results.push(this.fontSize(parseFloat(val)));
            break;
          case 'fontFamily':
            this.desiredFontFamily = val;
            _results.push(this.font(getFontString(this.desiredFontFamily, this.desiredFontWeight, this.desiredFontStyle)));
            break;
          case 'fontWeight':
            this.desiredFontWeight = val;
            _results.push(this.font(getFontString(this.desiredFontFamily, this.desiredFontWeight, this.desiredFontStyle)));
            break;
          case 'fontStyle':
            this.desiredFontStyle = val;
            _results.push(this.font(getFontString(this.desiredFontFamily, this.desiredFontWeight, this.desiredFontStyle)));
            break;
          default:
            _results.push(void 0);
        }
      }
      return _results;
    },
    beginPath: function() {},
    fillRect: function(x, y, w, h) {
      this.moveTo(0, 0);
      this.lineTo(w, 0);
      this.lineTo(w, h);
      this.lineTo(0, h);
      this.closePath();
      return this.fill();
    },
    strokeRect: function(x, y, w, h) {
      this.moveTo(0, 0);
      this.lineTo(w, 0);
      this.lineTo(w, h);
      this.lineTo(0, h);
      this.closePath();
      return this.stroke();
    },
    text: function(str, x, y, textanchor) {
      var offset_x, offset_y, textAlign, textBaseline, textHeight, textWidth;
      textAlign = 'center';
      if (textanchor.match('left')) {
        textAlign = 'right';
      } else if (textanchor.match('right')) {
        textAlign = 'left';
      }
      textBaseline = 'middle';
      if (textanchor.match('above')) {
        textBaseline = 'bottom';
      } else if (textanchor.match('below')) {
        textBaseline = 'top';
      }
      textHeight = this.currentLineHeight();
      textWidth = this.widthOfString(str);
      offset_x = 0;
      offset_y = 0;
      switch (textAlign) {
        case 'right':
          offset_x = -textWidth;
          break;
        case 'center':
          offset_x = -textWidth / 2;
      }
      switch (textBaseline) {
        case 'bottom':
          offset_y = -textHeight;
          break;
        case 'middle':
          offset_y = -textHeight / 2;
      }
      return this.text(str, x + offset_x, y + offset_y);
    }
  };

  RecordableCanvas.prototype._playbackOverridesSvg = {};

  return RecordableCanvas;

})();

/*
# Class that uses esprima and escodegen
# to rewrite code. Specifically, it can
# add foo.lineNumber = <num> markers before
# each function call, and prefix function
# calls and variable assignments, e.g.
# bar() -> foo.bar()
# bar = 5 -> foo.bar = 5
*/


SourceModifier = (function() {
  var encloseInBlock;

  encloseInBlock = function(tree) {
    var newElm;
    if (tree.type === 'BlockStatement') {
      return tree;
    } else {
      newElm = {
        type: 'BlockStatement',
        body: [tree]
      };
      return newElm;
    }
  };

  function SourceModifier(source) {
    this.source = source;
  }

  SourceModifier.prototype.parse = function(str) {
    var _ref;
    if (str == null) {
      str = this.source || '';
    }
    try {
      this.tree = esprima.parse(str, {
        loc: true
      });
    } catch (e) {
      e.sourceLine = str.split('\n')[e.lineNumber - 1];
      throw e;
    }
    return _ref = this.walk(this.tree), this.assignments = _ref.assignments, this.calls = _ref.calls, this.blocks = _ref.blocks, _ref;
  };

  SourceModifier.prototype.generateCode = function() {
    if (!(this.tree != null)) {
      throw new Error('You must run parse() before calling generateCode()');
    }
    return escodegen.generate(this.tree);
  };

  SourceModifier.prototype.prefixAssignments = function(val, prefixKeywords, assign) {
    var a, newNode, _i, _len;
    if (val == null) {
      val = 'foo';
    }
    if (prefixKeywords == null) {
      prefixKeywords = null;
    }
    if (assign == null) {
      assign = this.assignments;
    }
    for (_i = 0, _len = assign.length; _i < _len; _i++) {
      a = assign[_i];
      if (a.type === 'Identifier' && (prefixKeywords === null || a.name in prefixKeywords)) {
        newNode = {
          type: 'MemberExpression',
          object: {
            type: 'Identifier',
            name: val
          },
          property: a
        };
        a.parent.left = newNode;
      }
    }
  };

  SourceModifier.prototype.prefixCalls = function(val, prefixKeywords, calls) {
    var a, newNode, _i, _len;
    if (val == null) {
      val = 'foo';
    }
    if (prefixKeywords == null) {
      prefixKeywords = null;
    }
    if (calls == null) {
      calls = this.calls;
    }
    for (_i = 0, _len = calls.length; _i < _len; _i++) {
      a = calls[_i];
      if (a.type === 'Identifier' && (prefixKeywords === null || a.name in prefixKeywords)) {
        newNode = {
          type: 'MemberExpression',
          object: {
            type: 'Identifier',
            name: val
          },
          property: a
        };
        a.parent.callee = newNode;
      }
    }
  };

  SourceModifier.prototype.insertLineNumbers = function(val, blocks) {
    var b, i, newNode, node, _i, _len, _ref;
    if (val == null) {
      val = 'foo';
    }
    if (blocks == null) {
      blocks = this.blocks;
    }
    for (_i = 0, _len = blocks.length; _i < _len; _i++) {
      b = blocks[_i];
      i = 0;
      while (b[i] != null) {
        node = b[i];
        if (node.type === 'ExpressionStatement' && ((_ref = node.expression.type) === 'CallExpression' || _ref === 'Identifier' || _ref === 'Literal')) {
          node = node.expression;
          newNode = {
            type: 'ExpressionStatement',
            expression: {
              type: 'AssignmentExpression',
              operator: '=',
              left: {
                type: 'MemberExpression',
                object: {
                  type: 'Identifier',
                  name: val
                },
                property: {
                  type: 'Identifier',
                  name: 'lineNumber'
                }
              },
              right: {
                type: 'Literal',
                value: node.loc.start.line
              }
            }
          };
          b.splice(i, 0, newNode);
          i++;
        }
        i++;
      }
    }
  };

  SourceModifier.prototype.walk = function(tree, tracked) {
    var e, _i, _len, _ref;
    if (tracked == null) {
      tracked = {
        assignments: [],
        calls: [],
        blocks: []
      };
    }
    if (!(tree != null)) {
      return;
    }
    if (typeOf(tree) === 'array') {
      for (_i = 0, _len = tree.length; _i < _len; _i++) {
        e = tree[_i];
        this.walk(e, tracked);
      }
    } else {
      switch (tree.type) {
        case 'Program':
          tracked['blocks'].push(tree.body);
          this.walk(tree.body, tracked);
          break;
        case 'BlockStatement':
          this.walk(tree.body, tracked);
          break;
        case 'ForStatement':
          tree.body = encloseInBlock(tree.body);
          tracked['blocks'].push(tree.body.body);
          this.walk(tree.body, tracked);
          this.walk(tree.init, tracked);
          this.walk(tree.test, tracked);
          this.walk(tree.update, tracked);
          break;
        case 'ForInStatement':
          tree.body = encloseInBlock(tree.body);
          tracked['blocks'].push(tree.body.body);
          this.walk(tree.body, tracked);
          this.walk(tree.left, tracked);
          this.walk(tree.right, tracked);
          break;
        case 'WhileStatement':
          tree.body = encloseInBlock(tree.body);
          tracked['blocks'].push(tree.body.body);
          this.walk(tree.body, tracked);
          this.walk(tree.test, tracked);
          break;
        case 'IfStatement':
          tree.consequent = encloseInBlock(tree.consequent);
          tracked['blocks'].push(tree.consequent.body);
          this.walk(tree.test, tracked);
          this.walk(tree.consequent, tracked);
          break;
        case 'TryStatement':
          tree.block = encloseInBlock(tree.block);
          tracked['blocks'].push(tree.block.body);
          this.walk(tree.block, tracked);
          this.walk(tree.finalizer, tracked);
          this.walk(tree.handlers, tracked);
          break;
        case 'CatchClause':
          tree.body = encloseInBlock(tree.body);
          tracked['blocks'].push(tree.body.body);
          this.walk(tree.body, tracked);
          break;
        case 'FunctionDeclaration':
        case 'FunctionExpression':
          tree.body = encloseInBlock(tree.body);
          tracked['blocks'].push(tree.body.body);
          this.walk(tree.body, tracked);
          break;
        case 'UpdateExpression':
          this.walk(tree.argument, tracked);
          break;
        case 'BinaryExpression':
          this.walk(tree.left, tracked);
          this.walk(tree.right, tracked);
          break;
        case 'ExpressionStatement':
          this.walk(tree.expression, tracked);
          if ((_ref = tree.expression.type) === 'Identifier' || _ref === 'Literal') {
            tracked.calls.push(tree);
          }
          break;
        case 'CallExpression':
          tree.callee.parent = tree;
          tracked['calls'].push(tree.callee);
          this.walk(tree["arguments"], tracked);
          break;
        case 'AssignmentExpression':
          tree.left.parent = tree;
          tracked['assignments'].push(tree.left);
          this.walk(tree.right, tracked);
      }
    }
    return tracked;
  };

  return SourceModifier;

})();

/*
# All the useful math functions
*/


MathFunctions = {
  random: Math.random,
  tan: Math.tan,
  min: Math.min,
  PI: Math.PI,
  sqrt: Math.sqrt,
  E: Math.E,
  SQRT1_2: Math.SQRT1_2,
  ceil: Math.ceil,
  atan2: Math.atan2,
  cos: Math.cos,
  LN2: Math.LN2,
  LOG10E: Math.LOG10E,
  exp: Math.exp,
  round: function(n, places) {
    var shift;
    shift = Math.pow(10, places);
    return Math.round(n * shift) / shift;
  },
  atan: Math.atan,
  max: Math.max,
  pow: Math.pow,
  LOG2E: Math.LOG2E,
  log: Math.log,
  LN10: Math.LN10,
  floor: Math.floor,
  SQRT2: Math.SQRT2,
  asin: Math.asin,
  acos: Math.acos,
  sin: Math.sin,
  abs: Math.abs,
  cpi: "\u03C0",
  ctheta: "\u03B8",
  pi: Math.PI,
  ln: Math.log,
  e: Math.E,
  sign: function(x) {
    if (x === 0) {
      return 0;
    } else {
      if (x < 0) {
        return -1;
      } else {
        return 1;
      }
    }
  },
  arcsin: Math.asin,
  arccos: Math.acos,
  arctan: Math.atan,
  sinh: function(x) {
    return (Math.exp(x) - Math.exp(-x)) / 2;
  },
  cosh: function(x) {
    return (Math.exp(x) + Math.exp(-x)) / 2;
  },
  tanh: function(x) {
    return (Math.exp(x) - Math.exp(-x)) / (Math.exp(x) + Math.exp(-x));
  },
  arcsinh: function(x) {
    return ln(x + Math.sqrt(x * x + 1));
  },
  arccosh: function(x) {
    return ln(x + Math.sqrt(x * x - 1));
  },
  arctanh: function(x) {
    return ln((1 + x) / (1 - x)) / 2;
  },
  sech: function(x) {
    return 1 / cosh(x);
  },
  csch: function(x) {
    return 1 / sinh(x);
  },
  coth: function(x) {
    return 1 / tanh(x);
  },
  arcsech: function(x) {
    return arccosh(1 / x);
  },
  arccsch: function(x) {
    return arcsinh(1 / x);
  },
  arccoth: function(x) {
    return arctanh(1 / x);
  },
  sec: function(x) {
    return 1 / Math.cos(x);
  },
  csc: function(x) {
    return 1 / Math.sin(x);
  },
  cot: function(x) {
    return 1 / Math.tan(x);
  },
  arcsec: function(x) {
    return arccos(1 / x);
  },
  arccsc: function(x) {
    return arcsin(1 / x);
  },
  arccot: function(x) {
    return arctan(1 / x);
  }
};

/*
# The AsciiSVG object. When asciisvg
# code is evaled, it is first preparsed and any keyword belonging
# to the public api is prefixed so that it is actually an attribute
# access.  For example "plot(...)" would get turned
# into "api.plot(...)". This is a workaround since we can't define dynamic scope
# in javascript without using the With statement.  Note, all MathFunctions
# are added to the api
#
# In general, methods starting with _ are for device coordinates
*/


AsciiSVG = (function() {
  var api, arr, item, mathjs, round;

  arr = [];

  for (item in MathFunctions) {
    arr.push("" + item + " = MathFunctions." + item);
  }

  eval("var " + (arr.join(',')));

  round = function(n, places) {
    var shift;
    shift = Math.pow(10, places);
    return Math.round(n * shift) / shift;
  };

  api = {};

  AsciiSVG.prototype._toDeviceCoordinates = function(p) {
    return [p[0] * this._xunitlength + this._origin[0], api.height - p[1] * this._yunitlength - this._origin[1]];
  };

  AsciiSVG.prototype.constants = {
    xmin: {
      "default": -5,
      type: 'number',
      description: 'Override the minimum x value of a plot (shouldn\'t be used)'
    },
    xmax: {
      "default": 5,
      type: 'number',
      description: 'Override the maximum x value of a plot (shouldn\'t be used)'
    },
    ymin: {
      "default": -5,
      type: 'number',
      description: 'Override the minimum y value of a plot (shouldn\'t be used)'
    },
    ymax: {
      "default": 5,
      type: 'number',
      description: 'Override the maximum y value of a plot (shouldn\'t be used)'
    },
    border: {
      "default": 0,
      type: 'number',
      description: 'Unused'
    },
    width: {
      "default": null,
      type: 'number',
      description: 'Override the width of a plot (shouldn\'t be used)'
    },
    height: {
      "default": null,
      type: 'number',
      description: 'Override the height of a plot (shouldn\'t be used)'
    },
    fontsize: {
      "default": null,
      type: 'number',
      description: 'Size of text'
    },
    fontfamily: {
      "default": 'sans',
      type: 'string',
      description: 'What font family to use',
      options: ['sans', 'serif', 'Helvetica', 'Times', 'Courier']
    },
    fontstyle: {
      "default": 'normal',
      type: 'string',
      description: 'Whether your font should be normal or italic',
      options: ['normal', 'italic']
    },
    fontweight: {
      "default": 'normal',
      type: 'string',
      description: 'Whether your font should be normal or bold',
      options: ['normal', 'bold']
    },
    fontfill: {
      "default": 'black',
      type: 'color',
      description: 'Color of text'
    },
    fontstroke: {
      "default": 'none',
      type: 'color',
      description: 'Color outlining each letter in a text string'
    },
    markersize: {
      "default": 4,
      type: 'number',
      description: 'The size of an arrowhead'
    },
    marker: {
      "default": null,
      type: 'number',
      description: '',
      options: ['arrow', 'dot', 'arrowdot']
    },
    stroke: {
      "default": 'black',
      type: 'color',
      description: 'Color to draw lines with'
    },
    strokewidth: {
      "default": 1,
      type: 'number',
      description: 'Thickness of lines'
    },
    strokestyle: {
      "default": 'solid',
      type: 'string',
      description: 'What style lines should be drawn with',
      options: ['solid', 'dashed']
    },
    dasharray: {
      "default": [10, 5],
      type: 'array',
      description: 'For strokestyle="dashed" the array [strokelen, strokespace] will make a dash of length strokelen, then will draw nothing for strokespace, then repeats.'
    },
    background: {
      "default": 'white',
      type: 'color',
      description: 'Background color of plot'
    },
    gridstroke: {
      "default": '#aaaaaa',
      type: 'color',
      description: 'Color of gridlines of a plot'
    },
    fill: {
      "default": 'none',
      type: 'color',
      description: 'Color to fill shapes (circles/etc.) with'
    },
    axesstroke: {
      "default": 'black',
      type: 'color',
      description: 'Color of the the axes'
    },
    ticklength: {
      "default": 4,
      type: 'number',
      description: 'The length of the ticks that mark the units along the axes'
    },
    dotradius: {
      "default": 4,
      type: 'number',
      description: 'Radius (in pixels) of dots drawn (for instance with the dot() command or marker="dot")'
    }
  };

  AsciiSVG.prototype.functions = {
    initPicture: {},
    axes: {},
    plot: {},
    dot: {},
    line: {},
    text: {},
    setBorder: {
      description: 'Does nothing; exists for backwards compatibility'
    },
    rect: {},
    circle: {},
    path: {},
    slopefield: {}
  };

  function AsciiSVG() {
    var val, _ref;
    api = {};
    _ref = this.constants;
    for (item in _ref) {
      val = _ref[item];
      api[item] = val["default"];
    }
    for (item in this.functions) {
      api[item] = this[item].bind(this);
    }
  }

  AsciiSVG.prototype._xunitlength = 1;

  AsciiSVG.prototype._yunitlength = 1;

  AsciiSVG.prototype._origin = [0, 0];

  AsciiSVG.prototype._resetDefaults = function() {
    var val, _ref, _results;
    this._xunitlength = 1;
    this._yunitlength = 1;
    _ref = this.constants;
    _results = [];
    for (item in _ref) {
      val = _ref[item];
      _results.push(api[item] = val["default"]);
    }
    return _results;
  };

  AsciiSVG.prototype.getApi = function() {
    return api;
  };

  AsciiSVG.prototype.updatePicture = function(src, target, renderMode) {
    var array_raw, canvas, canvas_ctx, id, source, svgCanvas;
    if (src == null) {
      src = this.src;
    }
    if (renderMode == null) {
      renderMode = 'svg';
    }
    this._resetDefaults();
    if (typeOf(target) === 'string') {
      target = document.getElementById(target);
    }
    api.width = parseInt(target.getAttribute('width'));
    api.height = parseInt(target.getAttribute('height'));
    id = target.getAttribute('id');
    this.ctx = new RecordableCanvas(api.width, api.height);
    this.initPicture();
    array_raw = src;
    array_raw = array_raw.replace(/plot\(\x20*([^\"f\[][^\n\r]+?)\,/g, "plot\(\"$1\",");
    array_raw = array_raw.replace(/plot\(\x20*([^\"f\[][^\n\r]+)\)/g, "plot(\"$1\")");
    array_raw = array_raw.replace(/([0-9])([a-zA-Z])/g, "$1*$2");
    array_raw = array_raw.replace(/\)([\(0-9a-zA-Z])/g, "\)*$1");
    source = new SourceModifier(array_raw);
    source.parse();
    source.prefixAssignments('api', api);
    source.prefixCalls('api', api);
    source.insertLineNumbers('api');
    try {
      eval(source.generateCode());
    } catch (e) {
      e.lineNumber = api.lineNumber;
      e.sourceLine = array_raw.split('\n')[e.lineNumber - 1];
      throw e;
    }
    switch (renderMode) {
      case 'canvas':
        canvas = $("<canvas width='" + api.width + "' height='" + api.height + "' id='" + id + "' />")[0];
        canvas_ctx = canvas.getContext('2d');
        this.ctx.playbackTo(canvas_ctx, 'canvas');
        target.parentNode.replaceChild(canvas, target);
        break;
      case 'svg':
        svgCanvas = new SvgCanvas(api.width, api.height);
        this.ctx.playbackTo(svgCanvas, 'svg');
        svgCanvas._root.setAttribute('id', id);
        target.parentNode.replaceChild(svgCanvas._root, target);
    }
  };

  AsciiSVG.prototype.initPicture = function(x_min, x_max, y_min, y_max) {
    if (y_min == null) {
      y_min = x_min;
    }
    if (y_max == null) {
      y_max = x_max;
    }
    if (x_min != null) {
      api.xmin = x_min;
    }
    if (x_max != null) {
      api.xmax = x_max;
    }
    if (y_min != null) {
      api.ymin = y_min;
    }
    if (y_max != null) {
      api.ymax = y_max;
    }
    if (api.xmin >= api.xmax || api.ymin >= api.ymax) {
      throw new Error("Dimensions [" + [api.xmin, api.xmax, api.ymin, api.ymax] + "] are not valid");
    }
    this._xunitlength = (api.width - 2 * api.border) / (api.xmax - api.xmin);
    this._yunitlength = (api.height - 2 * api.border) / (api.ymax - api.ymin);
    this._origin = [-api.xmin * this._xunitlength + api.border, -api.ymin * this._yunitlength + api.border];
    this.ctx.width = api.width;
    this.ctx.height = api.height;
    return this._noaxes();
  };

  AsciiSVG.prototype.text = function(pos, str, textanchor, angle, padding) {
    var computed_fontsize, p, padding_x, padding_y;
    if (textanchor == null) {
      textanchor = 'center';
    }
    if (angle == null) {
      angle = 0;
    }
    if (padding == null) {
      padding = 4;
    }
    computed_fontsize = api.fontsize || constants.fontsize["default"];
    p = this._toDeviceCoordinates(pos);
    if (angle !== 0) {
      throw new Error('rotations not yet supported');
      this.ctx.rotate(angle / (2 * pi));
    }
    padding_x = 0;
    padding_y = 0;
    if (textanchor.match('left')) {
      if (padding > 0) {
        padding_x -= padding + 3;
      }
    }
    if (textanchor.match('right')) {
      if (padding > 0) {
        padding_x += padding + 3;
      }
    }
    if (textanchor.match('above')) {
      padding_y -= padding;
    }
    if (textanchor.match('below')) {
      padding_y += padding;
    }
    this.ctx.font = "" + api.fontstyle + " " + api.fontweight + " " + computed_fontsize + "px " + api.fontfamily;
    this.ctx.fontFamily = api.fontfamily;
    this.ctx.fontSize = computed_fontsize;
    this.ctx.fontWeight = api.fontweight;
    this.ctx.fontStyle = api.fontstyle;
    this.ctx.fillStyle = api.fontfill;
    this.ctx.text(str, p[0] + padding_x, p[1] + padding_y, textanchor);
    return pos;
  };

  AsciiSVG.prototype.setBorder = function() {};

  AsciiSVG.prototype.axes = function(dx, dy, labels, griddx, griddy, units) {
    var labeldecimals_x, labeldecimals_y, labelplacement_x, labelplacement_y, labelposition_x, labelposition_y, p, padding, tickdx, tickdy, x, xunits, y, yunits;
    tickdx = dx != null ? dx * this._xunitlength : this._xunitlength;
    tickdy = dy != null ? dy * this._yunitlength : this._yunitlength;
    api.fontsize = api.fontsize || min(tickdx / 2, tickdy / 2, 16);
    if (typeOf(griddx) === 'number' && griddy === void 0) {
      griddy = griddx;
    }
    this.ctx.mozDash = api.strokestyle === 'dashed' ? api.dasharray : [1, 0];
    if ((griddx != null) || (griddy != null)) {
      this.ctx.beginPath();
      this.ctx.strokeStyle = api.gridstroke;
      this.ctx.lineWidth = 0.5;
      this.ctx.fillStyle = api.fill;
      if ((griddx != null) && griddx > 0) {
        x = MathFunctions.ceil(api.xmin / griddx) * griddx;
        while (x < api.xmax) {
          p = this._toDeviceCoordinates([x, 0]);
          this.ctx.moveTo(p[0], 0);
          this.ctx.lineTo(p[0], api.height);
          x += griddx;
        }
      }
      if ((griddy != null) && griddy > 0) {
        y = MathFunctions.ceil(api.ymin / griddy) * griddy;
        while (y < api.ymax) {
          p = this._toDeviceCoordinates([0, y]);
          this.ctx.moveTo(0, p[1]);
          this.ctx.lineTo(api.width, p[1]);
          y += griddy;
        }
      }
      this.ctx.stroke();
    }
    if ((dx != null) || (dy != null)) {
      this.ctx.beginPath();
      this.ctx.strokeStyle = api.axesstroke;
      this.ctx.fillStyle = api.fill;
      this.ctx.lineWidth = 1;
      p = this._toDeviceCoordinates([0, 0]);
      this.ctx.moveTo(0, p[1]);
      this.ctx.lineTo(api.width, p[1]);
      this.ctx.moveTo(p[0], 0);
      this.ctx.lineTo(p[0], api.height);
      if ((dx != null) && dx > 0) {
        x = MathFunctions.ceil(api.xmin / dx) * dx;
        while (x < api.xmax) {
          if (x === 0) {
            x += dx;
          }
          p = this._toDeviceCoordinates([x, 0]);
          this.ctx.moveTo(p[0], p[1] - api.ticklength);
          this.ctx.lineTo(p[0], p[1] + api.ticklength);
          x += dx;
        }
      }
      if ((dy != null) && dy > 0) {
        y = MathFunctions.ceil(api.ymin / dy) * dy;
        while (y < api.ymax) {
          if (y === 0) {
            y += dy;
          }
          p = this._toDeviceCoordinates([0, y]);
          this.ctx.moveTo(p[0] - api.ticklength, p[1]);
          this.ctx.lineTo(p[0] + api.ticklength, p[1]);
          y += dy;
        }
      }
      this.ctx.stroke();
    }
    if (labels != null) {
      xunits = yunits = '';
      labeldecimals_x = Math.floor(1.1 - Math.log(dx)) + 1;
      labeldecimals_y = Math.floor(1.1 - Math.log(dy)) + 1;
      padding = 2 * api.ticklength / this._yunitlength;
      labelposition_x = api.ymin > 0 || api.ymax < 0 ? api.ymin + padding : -padding;
      padding = 2 * api.ticklength / this._xunitlength;
      labelposition_y = api.xmin > 0 || api.xmax < 0 ? api.xmin + padding : -padding;
      labelplacement_x = api.ymin > 0 || api.ymax < 0 ? 'above' : 'below';
      labelplacement_y = api.xmin > 0 || api.xmax < 0 ? 'right' : 'left';
      x = Math.ceil(api.xmin / dx) * dx;
      while (x < api.xmax) {
        if (x === 0) {
          x += dx;
        }
        this.text([x, labelposition_x], "" + (round(x, labeldecimals_x)) + xunits, labelplacement_x);
        x += dx;
      }
      y = Math.ceil(api.ymin / dy) * dy;
      while (y < api.ymax) {
        if (y === 0) {
          y += dy;
        }
        this.text([labelposition_y, y], "" + (round(y, labeldecimals_y)) + yunits, labelplacement_y);
        y += dy;
      }
    }
  };

  AsciiSVG.prototype._noaxes = function() {
    this.ctx.fillStyle = api.background;
    this.ctx.fillRect(0, 0, api.width, api.height);
  };

  AsciiSVG.prototype.rect = function(corner1, corner2) {
    this._rect(this._toDeviceCoordinates(corner1), this._toDeviceCoordinates(corner2));
  };

  AsciiSVG.prototype._rect = function(corner1, corner2) {
    this.ctx.beginPath();
    this.ctx.moveTo(corner1[0], corner1[1]);
    this.ctx.lineTo(corner1[0], corner2[1]);
    this.ctx.lineTo(corner2[0], corner2[1]);
    this.ctx.lineTo(corner2[0], corner1[1]);
    this.ctx.closePath();
    this.ctx.fillStyle = api.fill;
    this.ctx.strokeStyle = api.stroke;
    this.ctx.mozDash = api.strokestyle === 'dashed' ? api.dasharray : [1, 0];
    if ((api.fill != null) && api.fill !== 'none') {
      this.ctx.fillAndStroke();
    } else {
      this.ctx.stroke();
    }
  };

  AsciiSVG.prototype.circle = function(center, radius, filled) {
    var p;
    if (filled == null) {
      filled = false;
    }
    p = this._toDeviceCoordinates(center);
    radius = radius * this._xunitlength;
    this.ctx.beginPath();
    this.ctx.lineWidth = api.strokewidth;
    this.ctx.strokeStyle = api.stroke;
    this.ctx.fillStyle = api.fill;
    this.ctx.circle(p[0], p[1], radius);
    this.ctx.mozDash = api.strokestyle === 'dashed' ? api.dasharray : [1, 0];
    if (filled) {
      this.ctx.fillAndStroke();
    } else {
      this.ctx.stroke();
    }
  };

  AsciiSVG.prototype.dot = function(center, type, label, textanchor, angle) {
    var p, prevFill;
    if (textanchor == null) {
      textanchor = 'below';
    }
    p = this._toDeviceCoordinates(center);
    this.ctx.strokeStyle = api.stroke;
    this.ctx.lineWidth = api.strokewidth;
    this.ctx.mozDash = null;
    switch (type) {
      case '+':
        this.ctx.beginPath();
        this.ctx.moveTo(p[0] - api.ticklength, p[1]);
        this.ctx.lineTo(p[0] + api.ticklength, p[1]);
        this.ctx.moveTo(p[0], p[1] - api.ticklength);
        this.ctx.lineTo(p[0], p[1] + api.ticklength);
        this.ctx.stroke();
        break;
      case '-':
        this.ctx.beginPath();
        this.ctx.moveTo(p[0] - api.ticklength, p[1]);
        this.ctx.lineTo(p[0] + api.ticklength, p[1]);
        this.ctx.stroke();
        break;
      case '|':
        this.ctx.beginPath();
        this.ctx.moveTo(p[0], p[1] - api.ticklength);
        this.ctx.lineTo(p[0], p[1] + api.ticklength);
        this.ctx.stroke();
        break;
      default:
        prevFill = api.fill;
        if (type != null ? type.match('open') : void 0) {
          api.fill = api.background;
        } else if (type != null ? type.match('closed') : void 0) {
          api.fill = api.stroke;
        }
        this.circle(center, api.dotradius / this._xunitlength, true);
        api.fill = prevFill;
    }
    if (label != null) {
      this.text(center, label, textanchor, angle, api.dotradius + 1);
    }
  };

  AsciiSVG.prototype.line = function(start, end) {
    var _ref;
    this.ctx.lineWidth = api.strokewidth;
    this.ctx.strokeStyle = api.stroke;
    this.ctx.mozDash = api.strokestyle === 'dashed' ? api.dasharray : [1, 0];
    this._line(this._toDeviceCoordinates(start), this._toDeviceCoordinates(end));
    if ((_ref = api.marker) === 'dot' || _ref === 'arrowdot') {
      this.dot(start);
      if (api.marker === 'arrowdot') {
        this.arrowhead(start, end);
      }
      this.dot(start);
    }
  };

  AsciiSVG.prototype._line = function(start, end) {
    this.ctx.beginPath();
    this.ctx.moveTo(start[0], start[1]);
    this.ctx.lineTo(end[0], end[1]);
    this.ctx.stroke();
  };

  AsciiSVG.prototype.path = function(plist) {
    var p, _i, _j, _len, _len1, _ref, _ref1;
    p = this._toDeviceCoordinates(plist[0]);
    this.ctx.beginPath();
    this.ctx.lineWidth = api.strokewidth;
    this.ctx.strokeStyle = api.stroke;
    this.ctx.fillStyle = api.fill;
    this.ctx.moveTo(p[0], p[1]);
    _ref = plist.slice(1);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      p = _ref[_i];
      p = this._toDeviceCoordinates(p);
      this.ctx.lineTo(p[0], p[1]);
    }
    this.ctx.mozDash = api.strokestyle === 'dashed' ? api.dasharray : [1, 0];
    this.ctx.stroke();
    if ((_ref1 = api.marker) === 'dot' || _ref1 === 'arrowdot') {
      for (_j = 0, _len1 = plist.length; _j < _len1; _j++) {
        p = plist[_j];
        this.dot(p);
      }
    }
  };

  AsciiSVG.prototype.plot = function(func, x_min, x_max, samples) {
    var f, g, i, inbounds, inc, p, pInBounds, pNext, pPrevious, paths, points, t, threshold, toFunc, workingPath, _i, _j, _k, _len, _len1;
    if (x_min == null) {
      x_min = api.xmin;
    }
    if (x_max == null) {
      x_max = api.xmax;
    }
    if (samples == null) {
      samples = 200;
    }
    toFunc = function(func) {
      var ret;
      switch (typeOf(func)) {
        case 'string':
          ret = null;
          eval("ret = function(x){ return " + (mathjs(func)) + " }");
          break;
        case 'function':
          ret = func;
          break;
        default:
          throw new Error("Unknown function type '" + func + "'");
      }
      return ret;
    };
    threshold = function(x) {
      var plotDiameter;
      plotDiameter = Math.max(1e-6, api.ymax - api.ymin, api.xmax - api.xmin);
      return Math.min(Math.max(x, api.ymin - plotDiameter * 100), api.ymax + plotDiameter * 100);
    };
    f = function(x) {
      return x;
    };
    g = null;
    switch (typeOf(func)) {
      case 'string':
      case 'function':
        g = toFunc(func);
        break;
      case 'array':
        f = toFunc(func[0]);
        g = toFunc(func[1]);
        break;
      default:
        throw new Error("Unknown function type '" + func + "'");
    }
    points = [];
    inc = Math.max(0.0000001, (x_max - x_min) / samples);
    for (t = _i = x_min; x_min <= x_max ? _i <= x_max : _i >= x_max; t = _i += inc) {
      p = [threshold(f(t)), threshold(g(t))];
      if (isNaN(p[0]) === false && isNaN(p[1]) === false) {
        points.push(p);
      }
    }
    inbounds = function(p) {
      if (p[1] > api.ymin && p[1] < api.ymax && p[0] > api.xmin && p[0] < api.xmax) {
        return true;
      }
      return false;
    };
    paths = [];
    workingPath = [];
    for (i = _j = 0, _len = points.length; _j < _len; i = ++_j) {
      p = points[i];
      pNext = points[i + 1];
      pPrevious = points[i - 1];
      pInBounds = inbounds(p);
      if (pNext && pInBounds === false && inbounds(pNext) === true) {
        paths.push(workingPath);
        workingPath = [];
        workingPath.push(p);
      } else if (pPrevious && pInBounds === false && inbounds(pPrevious) === true) {
        workingPath.push(p);
        paths.push(workingPath);
        workingPath = [];
      } else if (pInBounds) {
        workingPath.push(p);
      }
    }
    paths.push(workingPath);
    for (_k = 0, _len1 = paths.length; _k < _len1; _k++) {
      p = paths[_k];
      if (p.length > 0) {
        this.path(p);
      }
    }
  };

  AsciiSVG.prototype.slopefield = function(func, dx, dy) {
    var dz, g, gxy, l, pointList, u, v, x, x_min, y, y_min, _i, _j, _k, _len, _ref, _ref1;
    if (dx == null) {
      dx = 1;
    }
    if (dy == null) {
      dy = 1;
    }
    g = func;
    if (typeOf(func) === 'string') {
      eval("g = function(x,y){ return " + (mathjs(func)) + " }");
    }
    dz = sqrt(dx * dx + dy * dy) / 4;
    x_min = Math.ceil(api.xmin / dx) * dx;
    y_min = Math.ceil(api.ymin / dy) * dy;
    pointList = [];
    for (x = _i = x_min, _ref = api.xmax; x_min <= _ref ? _i <= _ref : _i >= _ref; x = _i += dx) {
      for (y = _j = y_min, _ref1 = api.ymax; y_min <= _ref1 ? _j <= _ref1 : _j >= _ref1; y = _j += dy) {
        gxy = g(x, y);
        if (!isNaN(gxy)) {
          if (abs(gxy) === Infinity) {
            u = 0;
            v = dz;
          } else {
            u = dz / sqrt(1 + gxy * gxy);
            v = gxy * u;
          }
          if ((api.xmin <= x && x <= api.xmax) && (api.ymin <= y && y <= api.ymax)) {
            pointList.push([[x - u, y - v], [x + u, y + v]]);
          }
        }
      }
    }
    for (_k = 0, _len = pointList.length; _k < _len; _k++) {
      l = pointList[_k];
      this.line(l[0], l[1]);
    }
  };

  AsciiSVG.prototype.arrowhead = function(p, q, size) {
    if (size == null) {
      size = api.markersize;
    }
    return this._arrowhead(this._toDeviceCoordinates(p), this._toDeviceCoordinates(q), size);
  };

  AsciiSVG.prototype._arrowhead = function(p, q, size) {
    var d, u, uperp;
    u = [p[0] - q[0], p[1] - q[1]];
    d = Math.sqrt(u[0] * u[0] + u[1] * u[1]);
    if (d > 1e-7) {
      u = [-u[0] / d, -u[1] / d];
      uperp = [-u[1], u[0]];
      this.ctx.lineWidth = size;
      this.ctx.strokeStyle = api.stroke;
      this.ctx.fillStyle = api.stroke;
      this.ctx.mozDash = null;
      this.ctx.beginPath();
      this.ctx.moveTo(q[0] - 15 * u[0] - 4 * uperp[0], q[1] - 15 * u[1] - 4 * uperp[1]);
      this.ctx.lineTo(q[0] - 3 * u[0], q[1] - 3 * u[1]);
      this.ctx.lineTo(q[0] - 15 * u[0] + 4 * uperp[0], q[1] - 15 * u[1] + 4 * uperp[1]);
      this.ctx.closePath();
      this.ctx.fillAndStroke();
    }
  };

  mathjs = function(st) {
    var ch, i, j, k, nested;
    st = st.replace(/\s/g, "");
    if (st.indexOf("^-1") !== -1) {
      st = st.replace(/sin\^-1/g, "arcsin");
      st = st.replace(/cos\^-1/g, "arccos");
      st = st.replace(/tan\^-1/g, "arctan");
      st = st.replace(/sec\^-1/g, "arcsec");
      st = st.replace(/csc\^-1/g, "arccsc");
      st = st.replace(/cot\^-1/g, "arccot");
      st = st.replace(/sinh\^-1/g, "arcsinh");
      st = st.replace(/cosh\^-1/g, "arccosh");
      st = st.replace(/tanh\^-1/g, "arctanh");
      st = st.replace(/sech\^-1/g, "arcsech");
      st = st.replace(/csch\^-1/g, "arccsch");
      st = st.replace(/coth\^-1/g, "arccoth");
    }
    st = st.replace(/^e$/g, "(E)");
    st = st.replace(/^e([^a-zA-Z])/g, "(E)$1");
    st = st.replace(/([^a-zA-Z])e([^a-zA-Z])/g, "$1(E)$2");
    st = st.replace(/([0-9])([\(a-zA-Z])/g, "$1*$2");
    st = st.replace(/\)([\(0-9a-zA-Z])/g, ")*$1");
    i = void 0;
    j = void 0;
    k = void 0;
    ch = void 0;
    nested = void 0;
    while ((i = st.indexOf("^")) !== -1) {
      if (i === 0) {
        throw new Error("missing argument for '^'");
      }
      j = i - 1;
      ch = st.charAt(j);
      if (ch >= "0" && ch <= "9") {
        j--;
        while (j >= 0 && (ch = st.charAt(j)) >= "0" && ch <= "9") {
          j--;
        }
        if (ch === ".") {
          j--;
          while (j >= 0 && (ch = st.charAt(j)) >= "0" && ch <= "9") {
            j--;
          }
        }
      } else if (ch === ")") {
        nested = 1;
        j--;
        while (j >= 0 && nested > 0) {
          ch = st.charAt(j);
          if (ch === "(") {
            nested--;
          } else {
            if (ch === ")") {
              nested++;
            }
          }
          j--;
        }
        while (j >= 0 && (ch = st.charAt(j)) >= "a" && ch <= "z" || ch >= "A" && ch <= "Z") {
          j--;
        }
      } else if (ch >= "a" && ch <= "z" || ch >= "A" && ch <= "Z") {
        j--;
        while (j >= 0 && (ch = st.charAt(j)) >= "a" && ch <= "z" || ch >= "A" && ch <= "Z") {
          j--;
        }
      } else {
        throw new Error("incorrect syntax in " + st + " at position " + j);
      }
      if (i === st.length - 1) {
        throw new Error("missing argument");
      }
      k = i + 1;
      ch = st.charAt(k);
      if (ch >= "0" && ch <= "9" || ch === "-") {
        k++;
        while (k < st.length && (ch = st.charAt(k)) >= "0" && ch <= "9") {
          k++;
        }
        if (ch === ".") {
          k++;
          while (k < st.length && (ch = st.charAt(k)) >= "0" && ch <= "9") {
            k++;
          }
        }
      } else if (ch === "(") {
        nested = 1;
        k++;
        while (k < st.length && nested > 0) {
          ch = st.charAt(k);
          if (ch === "(") {
            nested++;
          } else {
            if (ch === ")") {
              nested--;
            }
          }
          k++;
        }
      } else if (ch >= "a" && ch <= "z" || ch >= "A" && ch <= "Z") {
        k++;
        while (k < st.length && (ch = st.charAt(k)) >= "a" && ch <= "z" || ch >= "A" && ch <= "Z") {
          k++;
        }
      } else {
        throw new Error("incorrect syntax in " + st + " at position " + k);
      }
      st = st.slice(0, j + 1) + "pow(" + st.slice(j + 1, i) + "," + st.slice(i + 1, k) + ")" + st.slice(k);
    }
    while ((i = st.indexOf("!")) !== -1) {
      if (i === 0) {
        throw new Error("missing argument for '!'");
      }
      j = i - 1;
      ch = st.charAt(j);
      if (ch >= "0" && ch <= "9") {
        j--;
        while (j >= 0 && (ch = st.charAt(j)) >= "0" && ch <= "9") {
          j--;
        }
        if (ch === ".") {
          j--;
          while (j >= 0 && (ch = st.charAt(j)) >= "0" && ch <= "9") {
            j--;
          }
        }
      } else if (ch === ")") {
        nested = 1;
        j--;
        while (j >= 0 && nested > 0) {
          ch = st.charAt(j);
          if (ch === "(") {
            nested--;
          } else {
            if (ch === ")") {
              nested++;
            }
          }
          j--;
        }
        while (j >= 0 && (ch = st.charAt(j)) >= "a" && ch <= "z" || ch >= "A" && ch <= "Z") {
          j--;
        }
      } else if (ch >= "a" && ch <= "z" || ch >= "A" && ch <= "Z") {
        j--;
        while (j >= 0 && (ch = st.charAt(j)) >= "a" && ch <= "z" || ch >= "A" && ch <= "Z") {
          j--;
        }
      } else {
        throw new Error("incorrect syntax in " + st + " at position " + j);
      }
      st = st.slice(0, j + 1) + "factorial(" + st.slice(j + 1, i) + ")" + st.slice(i + 1);
    }
    return st;
  };

  return AsciiSVG;

})();

window.nAsciiSVG = new AsciiSVG;
